// This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.

import * as autoguard from "@joelek/ts-autoguard/dist/lib-shared";

export const Stream: autoguard.serialization.MessageGuard<Stream> = autoguard.guards.Object.of({
	"index": autoguard.guards.Number,
	"codec_type": autoguard.guards.String,
	"codec_name": autoguard.guards.String,
	"time_base": autoguard.guards.String,
	"start_pts": autoguard.guards.Number,
	"start_time": autoguard.guards.String,
	"tags": autoguard.guards.Group.of(autoguard.guards.Intersection.of(
		autoguard.guards.Record.of(autoguard.guards.String),
		autoguard.guards.Object.of({
			"language": autoguard.guards.String
		}, {})
	))
}, {
	"extradata": autoguard.guards.String
});

export type Stream = autoguard.guards.Object<{
	"index": autoguard.guards.Number,
	"codec_type": autoguard.guards.String,
	"codec_name": autoguard.guards.String,
	"time_base": autoguard.guards.String,
	"start_pts": autoguard.guards.Number,
	"start_time": autoguard.guards.String,
	"tags": autoguard.guards.Group<autoguard.guards.Intersection<[
		autoguard.guards.Record<autoguard.guards.String>,
		autoguard.guards.Object<{
			"language": autoguard.guards.String
		}, {}>
	]>>
}, {
	"extradata": autoguard.guards.String
}>;

export const VideoStream: autoguard.serialization.MessageGuard<VideoStream> = autoguard.guards.Group.of(autoguard.guards.Intersection.of(
	autoguard.guards.Reference.of(() => Stream),
	autoguard.guards.Object.of({
		"codec_type": autoguard.guards.StringLiteral.of("video"),
		"width": autoguard.guards.Number,
		"height": autoguard.guards.Number,
		"r_frame_rate": autoguard.guards.String
	}, {
		"sample_aspect_ratio": autoguard.guards.String,
		"display_aspect_ratio": autoguard.guards.String,
		"color_range": autoguard.guards.String,
		"color_space": autoguard.guards.String,
		"color_transfer": autoguard.guards.String,
		"color_primaries": autoguard.guards.String
	})
));

export type VideoStream = autoguard.guards.Group<autoguard.guards.Intersection<[
	autoguard.guards.Reference<Stream>,
	autoguard.guards.Object<{
		"codec_type": autoguard.guards.StringLiteral<"video">,
		"width": autoguard.guards.Number,
		"height": autoguard.guards.Number,
		"r_frame_rate": autoguard.guards.String
	}, {
		"sample_aspect_ratio": autoguard.guards.String,
		"display_aspect_ratio": autoguard.guards.String,
		"color_range": autoguard.guards.String,
		"color_space": autoguard.guards.String,
		"color_transfer": autoguard.guards.String,
		"color_primaries": autoguard.guards.String
	}>
]>>;

export const AudioStream: autoguard.serialization.MessageGuard<AudioStream> = autoguard.guards.Group.of(autoguard.guards.Intersection.of(
	autoguard.guards.Reference.of(() => Stream),
	autoguard.guards.Object.of({
		"codec_type": autoguard.guards.StringLiteral.of("audio"),
		"sample_rate": autoguard.guards.String,
		"channels": autoguard.guards.Number
	}, {})
));

export type AudioStream = autoguard.guards.Group<autoguard.guards.Intersection<[
	autoguard.guards.Reference<Stream>,
	autoguard.guards.Object<{
		"codec_type": autoguard.guards.StringLiteral<"audio">,
		"sample_rate": autoguard.guards.String,
		"channels": autoguard.guards.Number
	}, {}>
]>>;

export const SubtitleStream: autoguard.serialization.MessageGuard<SubtitleStream> = autoguard.guards.Group.of(autoguard.guards.Intersection.of(
	autoguard.guards.Reference.of(() => Stream),
	autoguard.guards.Object.of({
		"codec_type": autoguard.guards.StringLiteral.of("subtitle")
	}, {})
));

export type SubtitleStream = autoguard.guards.Group<autoguard.guards.Intersection<[
	autoguard.guards.Reference<Stream>,
	autoguard.guards.Object<{
		"codec_type": autoguard.guards.StringLiteral<"subtitle">
	}, {}>
]>>;

export const StreamType: autoguard.serialization.MessageGuard<StreamType> = autoguard.guards.Group.of(autoguard.guards.Union.of(
	autoguard.guards.Reference.of(() => VideoStream),
	autoguard.guards.Reference.of(() => AudioStream),
	autoguard.guards.Reference.of(() => SubtitleStream)
));

export type StreamType = autoguard.guards.Group<autoguard.guards.Union<[
	autoguard.guards.Reference<VideoStream>,
	autoguard.guards.Reference<AudioStream>,
	autoguard.guards.Reference<SubtitleStream>
]>>;

export const FFProbe: autoguard.serialization.MessageGuard<FFProbe> = autoguard.guards.Object.of({
	"streams": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => StreamType))
}, {});

export type FFProbe = autoguard.guards.Object<{
	"streams": autoguard.guards.Array<autoguard.guards.Reference<StreamType>>
}, {}>;

export namespace Autoguard {
	export const Guards = {
		"Stream": autoguard.guards.Reference.of(() => Stream),
		"VideoStream": autoguard.guards.Reference.of(() => VideoStream),
		"AudioStream": autoguard.guards.Reference.of(() => AudioStream),
		"SubtitleStream": autoguard.guards.Reference.of(() => SubtitleStream),
		"StreamType": autoguard.guards.Reference.of(() => StreamType),
		"FFProbe": autoguard.guards.Reference.of(() => FFProbe)
	};

	export type Guards = { [A in keyof typeof Guards]: ReturnType<typeof Guards[A]["as"]>; };

	export const Requests = {};

	export type Requests = { [A in keyof typeof Requests]: ReturnType<typeof Requests[A]["as"]>; };

	export const Responses = {};

	export type Responses = { [A in keyof typeof Responses]: ReturnType<typeof Responses[A]["as"]>; };
};
