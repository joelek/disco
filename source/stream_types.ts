// This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.

import * as autoguard from "@joelek/ts-autoguard";

export type Stream = {
	index: number,
	codec_type: string,
	codec_name: string,
	time_base: string,
	start_pts: number,
	start_time: string,
	extradata: string,
	tags: ({ [key: string]: string } & {
		language: string
	})
};

export const Stream = {
	as(subject: any, path: string = ""): Stream {
		return ((subject, path) => {
			if ((subject != null) && (subject.constructor === globalThis.Object)) {
				(autoguard.guards.Number.as)(subject.index, path + "." + "index");
				(autoguard.guards.String.as)(subject.codec_type, path + "." + "codec_type");
				(autoguard.guards.String.as)(subject.codec_name, path + "." + "codec_name");
				(autoguard.guards.String.as)(subject.time_base, path + "." + "time_base");
				(autoguard.guards.Number.as)(subject.start_pts, path + "." + "start_pts");
				(autoguard.guards.String.as)(subject.start_time, path + "." + "start_time");
				(autoguard.guards.String.as)(subject.extradata, path + "." + "extradata");
				((subject, path) => {
					((subject, path) => {
						if ((subject != null) && (subject.constructor === globalThis.Object)) {
							for (let key of globalThis.Object.keys(subject)) {
								(autoguard.guards.String.as)(subject[key], path + "[\"" + key + "\"]");
							}
							return subject;
						}
						throw "Type guard \"Record\" failed at \"" + path + "\"!";
					})(subject, path);
					((subject, path) => {
						if ((subject != null) && (subject.constructor === globalThis.Object)) {
							(autoguard.guards.String.as)(subject.language, path + "." + "language");
							return subject;
						}
						throw "Type guard \"Object\" failed at \"" + path + "\"!";
					})(subject, path);
					return subject;
				})(subject.tags, path + "." + "tags");
				return subject;
			}
			throw "Type guard \"Object\" failed at \"" + path + "\"!";
		})(subject, path);
	},
	is(subject: any): subject is Stream {
		try {
			Stream.as(subject);
		} catch (error) {
			return false;
		}
		return true;
	}
};

export type VideoStream = (Stream & {
	codec_type: "video",
	width: number,
	height: number,
	r_frame_rate: string,
	sample_aspect_ratio: string,
	display_aspect_ratio: string,
	color_range: (undefined | string),
	color_space: (undefined | string),
	color_transfer: (undefined | string),
	color_primaries: (undefined | string)
});

export const VideoStream = {
	as(subject: any, path: string = ""): VideoStream {
		return ((subject, path) => {
			(Stream.as)(subject, path);
			((subject, path) => {
				if ((subject != null) && (subject.constructor === globalThis.Object)) {
					((subject, path) => {
						if (subject === "video") {
							return subject;
						}
						throw "Type guard \"StringLiteral\" failed at \"" + path + "\"!";
					})(subject.codec_type, path + "." + "codec_type");
					(autoguard.guards.Number.as)(subject.width, path + "." + "width");
					(autoguard.guards.Number.as)(subject.height, path + "." + "height");
					(autoguard.guards.String.as)(subject.r_frame_rate, path + "." + "r_frame_rate");
					(autoguard.guards.String.as)(subject.sample_aspect_ratio, path + "." + "sample_aspect_ratio");
					(autoguard.guards.String.as)(subject.display_aspect_ratio, path + "." + "display_aspect_ratio");
					((subject, path) => {
						try {
							return (autoguard.guards.Undefined.as)(subject, path);
						} catch (error) {}
						try {
							return (autoguard.guards.String.as)(subject, path);
						} catch (error) {}
						throw "Type guard \"Union\" failed at \"" + path + "\"!";
					})(subject.color_range, path + "." + "color_range");
					((subject, path) => {
						try {
							return (autoguard.guards.Undefined.as)(subject, path);
						} catch (error) {}
						try {
							return (autoguard.guards.String.as)(subject, path);
						} catch (error) {}
						throw "Type guard \"Union\" failed at \"" + path + "\"!";
					})(subject.color_space, path + "." + "color_space");
					((subject, path) => {
						try {
							return (autoguard.guards.Undefined.as)(subject, path);
						} catch (error) {}
						try {
							return (autoguard.guards.String.as)(subject, path);
						} catch (error) {}
						throw "Type guard \"Union\" failed at \"" + path + "\"!";
					})(subject.color_transfer, path + "." + "color_transfer");
					((subject, path) => {
						try {
							return (autoguard.guards.Undefined.as)(subject, path);
						} catch (error) {}
						try {
							return (autoguard.guards.String.as)(subject, path);
						} catch (error) {}
						throw "Type guard \"Union\" failed at \"" + path + "\"!";
					})(subject.color_primaries, path + "." + "color_primaries");
					return subject;
				}
				throw "Type guard \"Object\" failed at \"" + path + "\"!";
			})(subject, path);
			return subject;
		})(subject, path);
	},
	is(subject: any): subject is VideoStream {
		try {
			VideoStream.as(subject);
		} catch (error) {
			return false;
		}
		return true;
	}
};

export type AudioStream = (Stream & {
	codec_type: "audio",
	sample_rate: string,
	channels: number
});

export const AudioStream = {
	as(subject: any, path: string = ""): AudioStream {
		return ((subject, path) => {
			(Stream.as)(subject, path);
			((subject, path) => {
				if ((subject != null) && (subject.constructor === globalThis.Object)) {
					((subject, path) => {
						if (subject === "audio") {
							return subject;
						}
						throw "Type guard \"StringLiteral\" failed at \"" + path + "\"!";
					})(subject.codec_type, path + "." + "codec_type");
					(autoguard.guards.String.as)(subject.sample_rate, path + "." + "sample_rate");
					(autoguard.guards.Number.as)(subject.channels, path + "." + "channels");
					return subject;
				}
				throw "Type guard \"Object\" failed at \"" + path + "\"!";
			})(subject, path);
			return subject;
		})(subject, path);
	},
	is(subject: any): subject is AudioStream {
		try {
			AudioStream.as(subject);
		} catch (error) {
			return false;
		}
		return true;
	}
};

export type SubtitleStream = (Stream & {
	codec_type: "subtitle"
});

export const SubtitleStream = {
	as(subject: any, path: string = ""): SubtitleStream {
		return ((subject, path) => {
			(Stream.as)(subject, path);
			((subject, path) => {
				if ((subject != null) && (subject.constructor === globalThis.Object)) {
					((subject, path) => {
						if (subject === "subtitle") {
							return subject;
						}
						throw "Type guard \"StringLiteral\" failed at \"" + path + "\"!";
					})(subject.codec_type, path + "." + "codec_type");
					return subject;
				}
				throw "Type guard \"Object\" failed at \"" + path + "\"!";
			})(subject, path);
			return subject;
		})(subject, path);
	},
	is(subject: any): subject is SubtitleStream {
		try {
			SubtitleStream.as(subject);
		} catch (error) {
			return false;
		}
		return true;
	}
};

export type StreamType = (VideoStream | AudioStream | SubtitleStream);

export const StreamType = {
	as(subject: any, path: string = ""): StreamType {
		return ((subject, path) => {
			try {
				return (VideoStream.as)(subject, path);
			} catch (error) {}
			try {
				return (AudioStream.as)(subject, path);
			} catch (error) {}
			try {
				return (SubtitleStream.as)(subject, path);
			} catch (error) {}
			throw "Type guard \"Union\" failed at \"" + path + "\"!";
		})(subject, path);
	},
	is(subject: any): subject is StreamType {
		try {
			StreamType.as(subject);
		} catch (error) {
			return false;
		}
		return true;
	}
};

export type FFProbe = {
	streams: StreamType[]
};

export const FFProbe = {
	as(subject: any, path: string = ""): FFProbe {
		return ((subject, path) => {
			if ((subject != null) && (subject.constructor === globalThis.Object)) {
				((subject, path) => {
					if ((subject != null) && (subject.constructor === globalThis.Array)) {
						for (let i = 0; i < subject.length; i++) {
							(StreamType.as)(subject[i], path + "[" + i + "]");
						}
						return subject;
					}
					throw "Type guard \"Array\" failed at \"" + path + "\"!";
				})(subject.streams, path + "." + "streams");
				return subject;
			}
			throw "Type guard \"Object\" failed at \"" + path + "\"!";
		})(subject, path);
	},
	is(subject: any): subject is FFProbe {
		try {
			FFProbe.as(subject);
		} catch (error) {
			return false;
		}
		return true;
	}
};

export type Autoguard = {
	Stream: Stream,
	VideoStream: VideoStream,
	AudioStream: AudioStream,
	SubtitleStream: SubtitleStream,
	StreamType: StreamType,
	FFProbe: FFProbe
};

export const Autoguard = {
	Stream: Stream,
	VideoStream: VideoStream,
	AudioStream: AudioStream,
	SubtitleStream: SubtitleStream,
	StreamType: StreamType,
	FFProbe: FFProbe
};
