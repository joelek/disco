define("build/pgssub", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse_pgssub_as_bmp = void 0;
    function log(message) {
        console.log(message);
    }
    function parse_palette_block(chunk) {
        let index = chunk.buffer.readUInt8(chunk.offset);
        chunk.offset += 1;
        let y = chunk.buffer.readUInt8(chunk.offset);
        chunk.offset += 1;
        let u = chunk.buffer.readUInt8(chunk.offset);
        chunk.offset += 1;
        let v = chunk.buffer.readUInt8(chunk.offset);
        chunk.offset += 1;
        let o = chunk.buffer.readUInt8(chunk.offset);
        chunk.offset += 1;
        return {
            index,
            y,
            u,
            v,
            o
        };
    }
    function parse_palette(chunk) {
        chunk.offset += 2;
        let count = (chunk.buffer.length - 2) / 5;
        let entries = new Array(count);
        for (let i = 0; i < count; i++) {
            entries[i] = parse_palette_block(chunk);
        }
        return {
            entries
        };
    }
    function parse_bitmap(chunk) {
        chunk.offset += 7;
        let w = chunk.buffer.readUInt16BE(chunk.offset);
        chunk.offset += 2;
        let h = chunk.buffer.readUInt16BE(chunk.offset);
        chunk.offset += 2;
        let buffer = Buffer.alloc(w * h);
        let x = 0;
        let y = 0;
        while (y < h) {
            let index = chunk.buffer.readUInt8(chunk.offset);
            chunk.offset += 1;
            let count = 1;
            if (index === 0) {
                let b1 = chunk.buffer.readUInt8(chunk.offset);
                chunk.offset += 1;
                let fa = ((b1 & 0x80) >> 7);
                let fb = ((b1 & 0x40) >> 6);
                if (fb === 0) {
                    count = ((b1 & 0x3F) >> 0);
                    if (count === 0) {
                        x = 0;
                        y += 1;
                    }
                }
                else {
                    let b2 = chunk.buffer.readUInt8(chunk.offset);
                    chunk.offset += 1;
                    count = ((b1 & 0x3F) << 8) | b2;
                }
                if (fa === 0) {
                    index = 0;
                }
                else {
                    index = chunk.buffer.readUInt8(chunk.offset);
                    chunk.offset += 1;
                }
            }
            for (let i = 0; i < count; i++) {
                buffer.writeUInt8(index, (y * w) + x);
                x += 1;
            }
        }
        return {
            w,
            h,
            buffer
        };
    }
    function parse_times_block(chunk) {
        chunk.offset += 4;
        let x = chunk.buffer.readUInt16BE(chunk.offset);
        chunk.offset += 2;
        let y = chunk.buffer.readUInt16BE(chunk.offset);
        chunk.offset += 2;
        return {
            x,
            y
        };
    }
    function parse_times(chunk) {
        let w = chunk.buffer.readUInt16BE(chunk.offset);
        chunk.offset += 2;
        let h = chunk.buffer.readUInt16BE(chunk.offset);
        chunk.offset += 2;
        chunk.offset += 1;
        let index = chunk.buffer.readUInt16BE(chunk.offset);
        chunk.offset += 2;
        chunk.offset += 3;
        let count = chunk.buffer.readUInt8(chunk.offset);
        chunk.offset += 1;
        let entries = new Array(count);
        for (let i = 0; i < count; i++) {
            entries[i] = parse_times_block(chunk);
        }
        return {
            w,
            h,
            index,
            entries
        };
    }
    function parse_size_block(chunk) {
        let id = chunk.buffer.readUInt8(chunk.offset);
        chunk.offset += 1;
        let x = chunk.buffer.readUInt16BE(chunk.offset);
        chunk.offset += 2;
        let y = chunk.buffer.readUInt16BE(chunk.offset);
        chunk.offset += 2;
        let w = chunk.buffer.readUInt16BE(chunk.offset);
        chunk.offset += 2;
        let h = chunk.buffer.readUInt16BE(chunk.offset);
        chunk.offset += 2;
        return {
            id,
            x,
            y,
            w,
            h
        };
    }
    function parse_size(chunk) {
        let count = chunk.buffer.readInt8(chunk.offset);
        chunk.offset += 1;
        let entries = new Array(count);
        for (let i = 0; i < count; i++) {
            entries[i] = parse_size_block(chunk);
        }
        return {
            entries
        };
    }
    function parse_end(chunk) {
    }
    function parse_pgssub(chunk) {
        let palette = Buffer.alloc(256 * 4);
        for (let i = 0; i < 256; i++) {
            palette.writeUInt8(16, (i * 4) + 0);
            palette.writeUInt8(0, (i * 4) + 1);
            palette.writeUInt8(0, (i * 4) + 2);
            palette.writeUInt8(0, (i * 4) + 3);
        }
        let bitmaps = new Array(0);
        let times = new Array(0);
        let sizes = new Array(0);
        while (true) {
            let type = chunk.buffer.readUInt8(chunk.offset);
            chunk.offset += 1;
            let size = chunk.buffer.readUInt16BE(chunk.offset);
            chunk.offset += 2;
            let data = chunk.buffer.slice(chunk.offset, chunk.offset + size);
            chunk.offset += size;
            if (false) {
            }
            else if (type === 0x14) {
                let custom_palette = parse_palette({ buffer: data, offset: 0 });
                for (let i = 0; i < custom_palette.entries.length; i++) {
                    let entry = custom_palette.entries[i];
                    palette.writeUInt8(entry.y, (entry.index * 4) + 0);
                    palette.writeUInt8(entry.u, (entry.index * 4) + 1);
                    palette.writeUInt8(entry.v, (entry.index * 4) + 2);
                    palette.writeUInt8(entry.o, (entry.index * 4) + 3);
                }
            }
            else if (type === 0x15) {
                bitmaps.push(parse_bitmap({ buffer: data, offset: 0 }));
            }
            else if (type === 0x16) {
                times.push(parse_times({ buffer: data, offset: 0 }));
            }
            else if (type === 0x17) {
                sizes.push(parse_size({ buffer: data, offset: 0 }));
            }
            else if (type === 0x80) {
                parse_end({ buffer: data, offset: 0 });
                break;
            }
            else {
                throw "";
            }
        }
        let w = 1920;
        let h = 1080;
        let buffer = Buffer.alloc(w * h);
        buffer.fill(255);
        for (let i = 0; i < bitmaps.length; i++) {
            let bitmap = bitmaps[i];
            let size = sizes[0].entries[0];
            if (size) {
                for (let y = 0; y < bitmap.h; y++) {
                    bitmap.buffer.copy(buffer, ((size.y + y) * w) + size.x, (y * size.w), (y * size.w) + size.w);
                }
            }
        }
        return {
            w,
            h,
            buffer,
            palette
        };
    }
    function trim_transparent_border(bitmap) {
        let x0 = 0;
        outer: for (; x0 < bitmap.w; x0++) {
            inner: for (let y = 0; y < bitmap.h; y++) {
                let k = bitmap.buffer.readUInt8((y * bitmap.w) + x0);
                if (bitmap.palette.readUInt8((k * 4) + 3) > 0) {
                    break outer;
                }
            }
        }
        let x1 = bitmap.w - 1;
        outer: for (; x1 > x0; x1--) {
            inner: for (let y = 0; y < bitmap.h; y++) {
                let k = bitmap.buffer.readUInt8((y * bitmap.w) + x1);
                if (bitmap.palette.readUInt8((k * 4) + 3) > 0) {
                    break outer;
                }
            }
        }
        let y0 = 0;
        outer: for (; y0 < bitmap.h; y0++) {
            inner: for (let x = x0; x <= x1; x++) {
                let k = bitmap.buffer.readUInt8((y0 * bitmap.w) + x);
                if (bitmap.palette.readUInt8((k * 4) + 3) > 0) {
                    break outer;
                }
            }
        }
        let y1 = bitmap.h - 1;
        outer: for (; y1 > y0; y1--) {
            inner: for (let x = x0; x <= x1; x++) {
                let k = bitmap.buffer.readUInt8((y1 * bitmap.w) + x);
                if (bitmap.palette.readUInt8((k * 4) + 3) > 0) {
                    break outer;
                }
            }
        }
        let w = x1 - x0 + 1;
        let h = y1 - y0 + 1;
        let buffer = Buffer.alloc(w * h);
        for (let y = 0; y < h; y++) {
            bitmap.buffer.copy(buffer, (y * w), ((y0 + y) * bitmap.w) + x0, ((y0 + y) * bitmap.w) + x0 + w);
        }
        return {
            ...bitmap,
            w,
            h,
            buffer
        };
    }
    function convert_to_brightness(bitmap) {
        let palette = Buffer.alloc(256 * 4);
        for (let i = 0; i < 256; i++) {
            let y = bitmap.palette.readUInt8((i * 4) + 0);
            let o = bitmap.palette.readUInt8((i * 4) + 3);
            let b = ((Math.max(16, Math.min(y, 235)) - 16) / (235 - 16) * 255) | 0;
            palette.writeUInt8(b, (i * 4) + 0);
            palette.writeUInt8(b, (i * 4) + 1);
            palette.writeUInt8(b, (i * 4) + 2);
            palette.writeUInt8(o, (i * 4) + 3);
        }
        return {
            ...bitmap,
            palette
        };
    }
    function blend_onto_black_background(bitmap) {
        let palette = Buffer.alloc(256 * 4);
        for (let i = 0; i < 256; i++) {
            let r = bitmap.palette.readUInt8((i * 4) + 0);
            let g = bitmap.palette.readUInt8((i * 4) + 1);
            let b = bitmap.palette.readUInt8((i * 4) + 2);
            let o = bitmap.palette.readUInt8((i * 4) + 3);
            r = (r * (o / 255)) | 0;
            g = (g * (o / 255)) | 0;
            b = (b * (o / 255)) | 0;
            o = 255;
            palette.writeUInt8(r, (i * 4) + 0);
            palette.writeUInt8(g, (i * 4) + 1);
            palette.writeUInt8(b, (i * 4) + 2);
            palette.writeUInt8(o, (i * 4) + 3);
        }
        return {
            ...bitmap,
            palette
        };
    }
    function invert_colors(bitmap) {
        let palette = Buffer.alloc(256 * 4);
        for (let i = 0; i < 256; i++) {
            let r = bitmap.palette.readUInt8((i * 4) + 0);
            let g = bitmap.palette.readUInt8((i * 4) + 1);
            let b = bitmap.palette.readUInt8((i * 4) + 2);
            let o = bitmap.palette.readUInt8((i * 4) + 3);
            r = 255 - r;
            g = 255 - g;
            b = 255 - b;
            palette.writeUInt8(r, (i * 4) + 0);
            palette.writeUInt8(g, (i * 4) + 1);
            palette.writeUInt8(b, (i * 4) + 2);
            palette.writeUInt8(o, (i * 4) + 3);
        }
        return {
            ...bitmap,
            palette
        };
    }
    function parse_pgssub_as_bmp(buffer) {
        let bitmap = parse_pgssub({ buffer: buffer, offset: 0 });
        bitmap = trim_transparent_border(bitmap);
        bitmap = convert_to_brightness(bitmap);
        bitmap = blend_onto_black_background(bitmap);
        bitmap = invert_colors(bitmap);
        return bitmap;
    }
    exports.parse_pgssub_as_bmp = parse_pgssub_as_bmp;
});
define("build/bmp", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.read_from = exports.write_to = void 0;
    function write_to(bitmap) {
        let buffers = new Array();
        let stride = (((bitmap.w + 3) >> 2) << 2);
        let bmp_header = Buffer.alloc(14);
        bmp_header.set(Buffer.from("BM", "binary"), 0);
        bmp_header.writeUInt32LE(14 + 40 + 256 * 4 + (stride * bitmap.h), 2);
        bmp_header.writeUInt16LE(0, 6);
        bmp_header.writeUInt16LE(0, 8);
        bmp_header.writeUInt32LE(14 + 40 + 256 * 4, 10);
        buffers.push(bmp_header);
        let dib_header = Buffer.alloc(40);
        dib_header.writeUInt32LE(40, 0);
        dib_header.writeInt32LE(bitmap.w, 4);
        dib_header.writeInt32LE(bitmap.h, 8);
        dib_header.writeUInt16LE(1, 12);
        dib_header.writeUInt16LE(8, 14);
        dib_header.writeUInt32LE(0, 16);
        dib_header.writeUInt32LE((stride * bitmap.h), 20);
        dib_header.writeInt32LE(2835, 24);
        dib_header.writeInt32LE(2835, 28);
        dib_header.writeUInt32LE(0, 32);
        dib_header.writeUInt32LE(0, 36);
        buffers.push(dib_header);
        buffers.push(bitmap.palette);
        for (let y = bitmap.h - 1; y >= 0; y--) {
            let row = Buffer.alloc(stride);
            bitmap.buffer.copy(row, 0, (y * bitmap.w), (y * bitmap.w) + bitmap.w);
            buffers.push(row);
        }
        return Buffer.concat(buffers);
    }
    exports.write_to = write_to;
    function read_from(source) {
        let bmp_header = source.slice(0, 14);
        let identifier = bmp_header.slice(0, 2);
        if (identifier.toString() !== "BM") {
            throw "";
        }
        let file_size = bmp_header.readUInt32LE(2);
        if (file_size !== source.byteLength) {
            throw "";
        }
        let reserved_a = bmp_header.readUInt16LE(6);
        let reserved_b = bmp_header.readUInt16LE(8);
        let pixel_array_offset = bmp_header.readUInt32LE(10);
        if (pixel_array_offset > source.byteLength) {
            throw "";
        }
        let dib_header = source.slice(14, 14 + source.readUInt32LE(14));
        if (false) {
        }
        else if (dib_header.byteLength === 40) {
            let signed_width = dib_header.readInt32LE(4);
            let signed_height = dib_header.readInt32LE(8);
            let number_of_color_planes = dib_header.readUInt16LE(12);
            if (number_of_color_planes !== 1) {
                throw "";
            }
            let bits_per_pixel = dib_header.readUInt16LE(14);
            let compression_method = dib_header.readUInt32LE(16);
            if (compression_method !== 0) {
                throw "";
            }
            let pixel_array_size = dib_header.readUInt32LE(20);
            let signed_horizontal_resolution = dib_header.readInt32LE(24);
            let signed_vertical_resolution = dib_header.readInt32LE(28);
            let number_of_palette_colors = dib_header.readUInt32LE(32);
            let number_of_important_colors = dib_header.readUInt32LE(36);
            let w = signed_width;
            let h = signed_height;
            let buffer = source.slice(pixel_array_offset, pixel_array_offset + pixel_array_size);
            let palette = Buffer.alloc(0);
            return {
                w,
                h,
                buffer,
                palette
            };
        }
        else {
            throw "";
        }
    }
    exports.read_from = read_from;
});
define("build/delete_tree", ["require", "exports", "fs", "path"], function (require, exports, libfs, libpath) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sync = exports.async = void 0;
    function async(root, cb) {
        libfs.stat(root, (error, stats) => {
            if (stats.isDirectory()) {
                libfs.readdir(root, (error, nodes) => {
                    nodes = nodes.map((node) => {
                        return libpath.join(root, node);
                    });
                    let pick_next = () => {
                        if (nodes.length > 0) {
                            let node = nodes.pop();
                            async(node, () => {
                                pick_next();
                            });
                        }
                        else {
                            libfs.rmdir(root, (error) => {
                                cb();
                            });
                        }
                    };
                    pick_next();
                });
            }
            else if (stats.isFile()) {
                libfs.unlink(root, (error) => {
                    cb();
                });
            }
            else {
                throw new Error();
            }
        });
    }
    exports.async = async;
    ;
    function sync(root) {
        let stats = libfs.statSync(root);
        if (stats.isDirectory()) {
            let nodes = libfs.readdirSync(root).map((node) => {
                return libpath.join(root, node);
            });
            nodes.forEach(sync);
            libfs.rmdirSync(root);
        }
        else if (stats.isFile()) {
            libfs.unlinkSync(root);
        }
        else {
            throw new Error();
        }
    }
    exports.sync = sync;
    ;
});
define("node_modules/@joelek/ts-autoguard/dist/lib-shared/serialization", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessageSerializer = exports.MessageGuardError = void 0;
    class MessageGuardError {
        constructor(guard, subject, path) {
            this.guard = guard;
            this.subject = subject;
            this.path = path;
        }
        getSubjectType() {
            if (this.subject === null) {
                return "null";
            }
            if (this.subject instanceof Array) {
                return "array";
            }
            return typeof this.subject;
        }
        toString() {
            return `The type ${this.getSubjectType()} at ${this.path} is type-incompatible with the expected type: ${this.guard.ts()}`;
        }
    }
    exports.MessageGuardError = MessageGuardError;
    ;
    class MessageSerializer {
        constructor(guards) {
            this.guards = guards;
        }
        deserialize(string, cb) {
            let json = JSON.parse(string);
            if ((json != null) && (json.constructor === Object)) {
                if ((json.type != null) && (json.type.constructor === String)) {
                    let type = json.type;
                    let data = json.data;
                    let guard = this.guards[type];
                    if (guard === undefined) {
                        throw "Unknown message type \"" + type + "\"!";
                    }
                    cb(type, guard.as(data));
                    return;
                }
            }
            throw "Invalid message envelope!";
        }
        serialize(type, data) {
            return JSON.stringify({
                type,
                data
            });
        }
    }
    exports.MessageSerializer = MessageSerializer;
    ;
});
define("node_modules/@joelek/ts-autoguard/dist/lib-shared/guards", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/serialization"], function (require, exports, serialization) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Union = exports.Undefined = exports.Tuple = exports.StringLiteral = exports.String = exports.Reference = exports.Record = exports.Object = exports.NumberLiteral = exports.Number = exports.Null = exports.Intersection = exports.Group = exports.BooleanLiteral = exports.Boolean = exports.Array = exports.Any = void 0;
    exports.Any = {
        as(subject, path = "") {
            return subject;
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        },
        ts(eol = "\n") {
            return `any`;
        }
    };
    exports.Array = {
        of(guard) {
            return {
                as(subject, path = "") {
                    if ((subject != null) && (subject.constructor === globalThis.Array)) {
                        for (let i = 0; i < subject.length; i++) {
                            guard.as(subject[i], path + "[" + i + "]");
                        }
                        return subject;
                    }
                    throw new serialization.MessageGuardError(this, subject, path);
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                },
                ts(eol = "\n") {
                    return `array<${guard.ts(eol)}>`;
                }
            };
        }
    };
    exports.Boolean = {
        as(subject, path = "") {
            if ((subject != null) && (subject.constructor === globalThis.Boolean)) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        },
        ts(eol = "\n") {
            return `boolean`;
        }
    };
    exports.BooleanLiteral = {
        of(value) {
            return {
                as(subject, path = "") {
                    if (subject === value) {
                        return subject;
                    }
                    throw new serialization.MessageGuardError(this, subject, path);
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                },
                ts(eol = "\n") {
                    return `${value}`;
                }
            };
        }
    };
    exports.Group = {
        of(guard, name) {
            return {
                as(subject, path = "") {
                    return guard.as(subject, path);
                },
                is(subject) {
                    return guard.is(subject);
                },
                ts(eol = "\n") {
                    return name !== null && name !== void 0 ? name : guard.ts(eol);
                }
            };
        }
    };
    exports.Intersection = {
        of(...guards) {
            return {
                as(subject, path = "") {
                    for (let guard of guards) {
                        guard.as(subject, path);
                    }
                    return subject;
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                },
                ts(eol = "\n") {
                    let lines = new globalThis.Array();
                    for (let guard of guards) {
                        lines.push("\t" + guard.ts(eol + "\t"));
                    }
                    return "intersection<" + eol + lines.join("," + eol) + eol + ">";
                }
            };
        }
    };
    exports.Null = {
        as(subject, path = "") {
            if (subject === null) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        },
        ts(eol = "\n") {
            return `null`;
        }
    };
    exports.Number = {
        as(subject, path = "") {
            if ((subject != null) && (subject.constructor === globalThis.Number)) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        },
        ts(eol = "\n") {
            return `number`;
        }
    };
    exports.NumberLiteral = {
        of(value) {
            return {
                as(subject, path = "") {
                    if (subject === value) {
                        return subject;
                    }
                    throw new serialization.MessageGuardError(this, subject, path);
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                },
                ts(eol = "\n") {
                    return `${value}`;
                }
            };
        }
    };
    exports.Object = {
        of(required, optional) {
            return {
                as(subject, path = "") {
                    if ((subject != null) && (subject.constructor === globalThis.Object)) {
                        for (let key in required) {
                            required[key].as(subject[key], path + (/^([a-z][a-z0-9_]*)$/isu.test(key) ? "." + key : "[\"" + key + "\"]"));
                        }
                        for (let key in optional) {
                            if (key in subject && subject[key] !== undefined) {
                                optional[key].as(subject[key], path + (/^([a-z][a-z0-9_]*)$/isu.test(key) ? "." + key : "[\"" + key + "\"]"));
                            }
                        }
                        return subject;
                    }
                    throw new serialization.MessageGuardError(this, subject, path);
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                },
                ts(eol = "\n") {
                    let lines = new globalThis.Array();
                    for (let [key, value] of globalThis.Object.entries(required)) {
                        lines.push(`\t"${key}": ${value.ts(eol + "\t")}`);
                    }
                    for (let [key, value] of globalThis.Object.entries(optional !== null && optional !== void 0 ? optional : {})) {
                        lines.push(`\t"${key}"?: ${value.ts(eol + "\t")}`);
                    }
                    return "object<" + eol + lines.join("," + eol) + eol + ">";
                }
            };
        }
    };
    exports.Record = {
        of(guard) {
            return {
                as(subject, path = "") {
                    if ((subject != null) && (subject.constructor === globalThis.Object)) {
                        let wrapped = exports.Union.of(exports.Undefined, guard);
                        for (let key of globalThis.Object.keys(subject)) {
                            wrapped.as(subject[key], path + "[\"" + key + "\"]");
                        }
                        return subject;
                    }
                    throw new serialization.MessageGuardError(this, subject, path);
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                },
                ts(eol = "\n") {
                    return `record<${guard.ts(eol)}>`;
                }
            };
        }
    };
    exports.Reference = {
        of(guard) {
            return {
                as(subject, path = "") {
                    return guard().as(subject, path);
                },
                is(subject) {
                    return guard().is(subject);
                },
                ts(eol = "\n") {
                    return guard().ts(eol);
                }
            };
        }
    };
    exports.String = {
        as(subject, path = "") {
            if ((subject != null) && (subject.constructor === globalThis.String)) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        },
        ts(eol = "\n") {
            return "string";
        }
    };
    exports.StringLiteral = {
        of(value) {
            return {
                as(subject, path = "") {
                    if (subject === value) {
                        return subject;
                    }
                    throw new serialization.MessageGuardError(this, subject, path);
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                },
                ts(eol = "\n") {
                    return `"${value}"`;
                }
            };
        }
    };
    exports.Tuple = {
        of(...guards) {
            return {
                as(subject, path = "") {
                    if ((subject != null) && (subject.constructor === globalThis.Array)) {
                        for (let i = 0; i < guards.length; i++) {
                            guards[i].as(subject[i], path + "[" + i + "]");
                        }
                        return subject;
                    }
                    throw new serialization.MessageGuardError(this, subject, path);
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                },
                ts(eol = "\n") {
                    let lines = new globalThis.Array();
                    for (let guard of guards) {
                        lines.push(`\t${guard.ts(eol + "\t")}`);
                    }
                    return "tuple<" + eol + lines.join("," + eol) + eol + ">";
                }
            };
        }
    };
    exports.Undefined = {
        as(subject, path = "") {
            if (subject === undefined) {
                return subject;
            }
            throw new serialization.MessageGuardError(this, subject, path);
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        },
        ts(eol = "\n") {
            return "undefined";
        }
    };
    exports.Union = {
        of(...guards) {
            return {
                as(subject, path = "") {
                    for (let guard of guards) {
                        try {
                            return guard.as(subject, path);
                        }
                        catch (error) { }
                    }
                    throw new serialization.MessageGuardError(this, subject, path);
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                },
                ts(eol = "\n") {
                    let lines = new globalThis.Array();
                    for (let guard of guards) {
                        lines.push("\t" + guard.ts(eol + "\t"));
                    }
                    return "union<" + eol + lines.join("," + eol) + eol + ">";
                }
            };
        }
    };
});
define("node_modules/@joelek/ts-autoguard/dist/lib-shared/api", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/guards"], function (require, exports, guards) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                }
                catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator["throw"](value));
                }
                catch (e) {
                    reject(e);
                }
            }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __asyncValues = (this && this.__asyncValues) || function (o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deserializePayload = exports.deserializeStringPayload = exports.compareArrays = exports.serializePayload = exports.serializeStringPayload = exports.collectPayload = exports.deserializeValue = exports.serializeValue = exports.Headers = exports.Options = exports.JSON = exports.Primitive = exports.Binary = exports.SyncBinary = exports.AsyncBinary = exports.decodeUndeclaredHeaders = exports.decodeHeaderValue = exports.decodeHeaderValues = exports.decodeUndeclaredParameters = exports.decodeParameterValue = exports.decodeParameterValues = exports.encodeUndeclaredParameterPairs = exports.encodeParameterPairs = exports.escapeParameterValue = exports.escapeParameterKey = exports.encodeComponents = exports.escapeComponent = exports.encodeUndeclaredHeaderPairs = exports.encodeHeaderPairs = exports.escapeHeaderValue = exports.escapeHeaderKey = exports.splitHeaders = exports.combineParameters = exports.splitParameters = exports.combineComponents = exports.splitComponents = exports.decodeURIComponent = void 0;
    function decodeURIComponent(string) {
        try {
            return globalThis.decodeURIComponent(string);
        }
        catch (error) { }
    }
    exports.decodeURIComponent = decodeURIComponent;
    ;
    function splitComponents(url) {
        let components = new Array();
        for (let part of url.split("?")[0].split("/").slice(1)) {
            components.push(part);
        }
        return components;
    }
    exports.splitComponents = splitComponents;
    ;
    function combineComponents(components) {
        return "/" + components.join("/");
    }
    exports.combineComponents = combineComponents;
    ;
    function splitParameters(url) {
        let parameters = new Array();
        let query = url.split("?").slice(1).join("?");
        if (query !== "") {
            for (let part of query.split("&")) {
                let parts = part.split("=");
                if (parts.length === 1) {
                    let key = parts[0];
                    let value = "";
                    parameters.push([key, value]);
                }
                else {
                    let key = parts[0];
                    let value = parts.slice(1).join("=");
                    parameters.push([key, value]);
                }
            }
        }
        return parameters;
    }
    exports.splitParameters = splitParameters;
    ;
    function combineParameters(parameters) {
        let parts = parameters.map((parameters) => {
            let key = parameters[0];
            let value = parameters[1];
            return `${key}=${value}`;
        });
        if (parts.length === 0) {
            return "";
        }
        return `?${parts.join("&")}`;
    }
    exports.combineParameters = combineParameters;
    ;
    function splitHeaders(lines) {
        return lines.map((part) => {
            let parts = part.split(":");
            if (parts.length === 1) {
                let key = parts[0].toLowerCase();
                let value = "";
                return [key, value];
            }
            else {
                let key = parts[0].toLowerCase();
                let value = parts.slice(1).join(":").trim();
                return [key, value];
            }
        });
    }
    exports.splitHeaders = splitHeaders;
    ;
    const RFC7320_DELIMITERS = "\"(),/:;<=>?@[\\]{}";
    const RFC7320_WHITESPACE = "\t ";
    // The specification (rfc7320) allows octets 33-126 and forbids delimiters. Octets 128-255 have been deprecated since rfc2616.
    function escapeHeaderKey(string, alwaysEncode = "") {
        return escapeHeaderValue(string, RFC7320_DELIMITERS + RFC7320_WHITESPACE + alwaysEncode);
    }
    exports.escapeHeaderKey = escapeHeaderKey;
    ;
    // The specification (rfc7320) allows octets 33-126 and whitespace. Octets 128-255 have been deprecated since rfc2616.
    function escapeHeaderValue(string, alwaysEncode = "") {
        return [...string]
            .map((codePointString) => {
            var _a;
            if (!alwaysEncode.includes(codePointString) && codePointString !== "%") {
                let codePoint = (_a = codePointString.codePointAt(0)) !== null && _a !== void 0 ? _a : 0;
                if (codePoint >= 33 && codePoint <= 126) {
                    return codePointString;
                }
                if (RFC7320_WHITESPACE.includes(codePointString)) {
                    return codePointString;
                }
            }
            return encodeURIComponent(codePointString);
        })
            .join("");
    }
    exports.escapeHeaderValue = escapeHeaderValue;
    ;
    function encodeHeaderPairs(key, values, plain) {
        let pairs = new Array();
        for (let value of values) {
            let serialized = serializeValue(value, plain);
            if (serialized !== undefined) {
                if (plain) {
                    pairs.push([
                        escapeHeaderKey(key),
                        escapeHeaderValue(serialized)
                    ]);
                }
                else {
                    pairs.push([
                        escapeHeaderKey(key),
                        escapeHeaderKey(serialized)
                    ]);
                }
            }
        }
        return pairs;
    }
    exports.encodeHeaderPairs = encodeHeaderPairs;
    ;
    function encodeUndeclaredHeaderPairs(record, exclude) {
        let pairs = new Array();
        for (let [key, value] of Object.entries(record)) {
            if (!exclude.includes(key) && value !== undefined) {
                if (guards.String.is(value)) {
                    pairs.push(...encodeHeaderPairs(key, [value], true));
                }
                else if (guards.Array.of(guards.String).is(value)) {
                    pairs.push(...encodeHeaderPairs(key, value, true));
                }
                else {
                    throw `Expected type of undeclared header "${key}" to be string or string[]!`;
                }
            }
        }
        return pairs;
    }
    exports.encodeUndeclaredHeaderPairs = encodeUndeclaredHeaderPairs;
    ;
    function escapeComponent(string) {
        return encodeURIComponent(string);
    }
    exports.escapeComponent = escapeComponent;
    ;
    function encodeComponents(values, plain) {
        let array = new Array();
        for (let value of values) {
            let serialized = serializeValue(value, plain);
            if (serialized !== undefined) {
                array.push(escapeComponent(serialized));
            }
        }
        return array;
    }
    exports.encodeComponents = encodeComponents;
    ;
    function escapeParameterKey(string) {
        return encodeURIComponent(string);
    }
    exports.escapeParameterKey = escapeParameterKey;
    ;
    function escapeParameterValue(string) {
        return encodeURIComponent(string);
    }
    exports.escapeParameterValue = escapeParameterValue;
    ;
    function encodeParameterPairs(key, values, plain) {
        let pairs = new Array();
        for (let value of values) {
            let serialized = serializeValue(value, plain);
            if (serialized !== undefined) {
                pairs.push([
                    escapeParameterKey(key),
                    escapeParameterValue(serialized)
                ]);
            }
        }
        return pairs;
    }
    exports.encodeParameterPairs = encodeParameterPairs;
    ;
    function encodeUndeclaredParameterPairs(record, exclude) {
        let pairs = new Array();
        for (let [key, value] of Object.entries(record)) {
            if (!exclude.includes(key) && value !== undefined) {
                if (guards.String.is(value)) {
                    pairs.push(...encodeParameterPairs(key, [value], true));
                }
                else if (guards.Array.of(guards.String).is(value)) {
                    pairs.push(...encodeParameterPairs(key, value, true));
                }
                else {
                    throw `Expected type of undeclared parameter "${key}" to be string or string[]!`;
                }
            }
        }
        return pairs;
    }
    exports.encodeUndeclaredParameterPairs = encodeUndeclaredParameterPairs;
    ;
    function decodeParameterValues(pairs, key, plain) {
        let values = new Array();
        for (let pair of pairs) {
            if (key === decodeURIComponent(pair[0])) {
                let parts = pair[1].split(",");
                for (let part of parts) {
                    let value = deserializeValue(decodeURIComponent(part), plain);
                    if (value === undefined) {
                        throw `Expected parameter "${key}" to be properly encoded!`;
                    }
                    values.push(value);
                }
            }
        }
        return values;
    }
    exports.decodeParameterValues = decodeParameterValues;
    ;
    function decodeParameterValue(pairs, key, plain) {
        let values = decodeParameterValues(pairs, key, plain);
        if (values.length > 1) {
            throw `Expected no more than one "${key}" parameter!`;
        }
        return values[0];
    }
    exports.decodeParameterValue = decodeParameterValue;
    ;
    function decodeUndeclaredParameters(pairs, exclude) {
        let map = {};
        for (let pair of pairs) {
            let key = decodeURIComponent(pair[0]);
            let value = decodeURIComponent(pair[1]);
            if (key === undefined || value === undefined) {
                throw `Expected undeclared parameter "${key}" to be properly encoded!`;
            }
            if (!exclude.includes(key)) {
                let values = map[key];
                if (values === undefined) {
                    values = new Array();
                    map[key] = values;
                }
                values.push(value);
            }
        }
        let record = {};
        for (let [key, value] of Object.entries(map)) {
            if (value.length === 1) {
                record[key] = value[0];
            }
            else {
                record[key] = value;
            }
        }
        return record;
    }
    exports.decodeUndeclaredParameters = decodeUndeclaredParameters;
    ;
    function decodeHeaderValues(pairs, key, plain) {
        let values = new Array();
        for (let pair of pairs) {
            if (key === decodeURIComponent(pair[0])) {
                let parts = pair[1].split(",");
                for (let part of parts) {
                    let value = deserializeValue(decodeURIComponent(part.trim()), plain);
                    if (value === undefined) {
                        throw `Expected header "${key}" to be properly encoded!`;
                    }
                    values.push(value);
                }
            }
        }
        return values;
    }
    exports.decodeHeaderValues = decodeHeaderValues;
    ;
    function decodeHeaderValue(pairs, key, plain) {
        let values = decodeHeaderValues(pairs, key, plain);
        if (values.length > 1) {
            throw `Expected no more than one "${key}" header!`;
        }
        return values[0];
    }
    exports.decodeHeaderValue = decodeHeaderValue;
    ;
    function decodeUndeclaredHeaders(pairs, exclude) {
        let map = {};
        for (let pair of pairs) {
            let key = decodeURIComponent(pair[0]);
            let value = decodeURIComponent(pair[1]);
            if (key === undefined || value === undefined) {
                throw `Expected undeclared header "${key}" to be properly encoded!`;
            }
            if (!exclude.includes(key)) {
                let values = map[key];
                if (values === undefined) {
                    values = new Array();
                    map[key] = values;
                }
                values.push(value);
            }
        }
        let record = {};
        for (let [key, value] of Object.entries(map)) {
            if (value.length === 1) {
                record[key] = value[0];
            }
            else {
                record[key] = value;
            }
        }
        return record;
    }
    exports.decodeUndeclaredHeaders = decodeUndeclaredHeaders;
    ;
    exports.AsyncBinary = {
        as(subject, path = "") {
            if (subject != null) {
                let member = subject[Symbol.asyncIterator];
                if (member != null && member.constructor === globalThis.Function) {
                    return subject;
                }
            }
            throw "Expected AsyncBinary at " + path + "!";
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        },
        ts(eol = "\n") {
            return `AsyncBinary`;
        }
    };
    exports.SyncBinary = {
        as(subject, path = "") {
            if (subject != null) {
                let member = subject[Symbol.iterator];
                if (member != null && member.constructor === globalThis.Function) {
                    return subject;
                }
            }
            throw "Expected SyncBinary at " + path + "!";
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        },
        ts(eol = "\n") {
            return `SyncBinary`;
        }
    };
    exports.Binary = guards.Union.of(exports.AsyncBinary, exports.SyncBinary);
    exports.Primitive = guards.Union.of(guards.Boolean, guards.Number, guards.String, guards.Undefined);
    exports.JSON = guards.Group.of(guards.Union.of(guards.Boolean, guards.Null, guards.Number, guards.String, guards.Array.of(guards.Reference.of(() => exports.JSON)), guards.Record.of(guards.Reference.of(() => exports.JSON)), guards.Undefined), "JSON");
    exports.Options = guards.Record.of(exports.JSON);
    exports.Headers = guards.Record.of(exports.JSON);
    function serializeValue(value, plain) {
        if (value === undefined) {
            return;
        }
        return plain ? String(value) : globalThis.JSON.stringify(value);
    }
    exports.serializeValue = serializeValue;
    ;
    function deserializeValue(value, plain) {
        if (value === undefined || plain) {
            return value;
        }
        try {
            return globalThis.JSON.parse(value);
        }
        catch (error) { }
    }
    exports.deserializeValue = deserializeValue;
    ;
    function collectPayload(binary) {
        var binary_1, binary_1_1;
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function* () {
            let chunks = new Array();
            let length = 0;
            try {
                for (binary_1 = __asyncValues(binary); binary_1_1 = yield binary_1.next(), !binary_1_1.done;) {
                    let chunk = binary_1_1.value;
                    chunks.push(chunk);
                    length += chunk.length;
                }
            }
            catch (e_1_1) {
                e_1 = { error: e_1_1 };
            }
            finally {
                try {
                    if (binary_1_1 && !binary_1_1.done && (_a = binary_1.return))
                        yield _a.call(binary_1);
                }
                finally {
                    if (e_1)
                        throw e_1.error;
                }
            }
            let payload = new Uint8Array(length);
            let offset = 0;
            for (let chunk of chunks) {
                payload.set(chunk, offset);
                offset += chunk.length;
            }
            return payload;
        });
    }
    exports.collectPayload = collectPayload;
    ;
    function serializeStringPayload(string) {
        // @ts-ignore
        let encoder = new TextEncoder();
        let array = encoder.encode(string);
        return [array];
    }
    exports.serializeStringPayload = serializeStringPayload;
    ;
    function serializePayload(payload) {
        let serialized = serializeValue(payload, false);
        if (serialized === undefined) {
            return [];
        }
        return serializeStringPayload(serialized);
    }
    exports.serializePayload = serializePayload;
    ;
    function compareArrays(one, two) {
        if (one.length !== two.length) {
            return false;
        }
        for (let i = 0; i < one.length; i++) {
            if (one[i] !== two[i]) {
                return false;
            }
        }
        return true;
    }
    exports.compareArrays = compareArrays;
    ;
    function deserializeStringPayload(binary) {
        return __awaiter(this, void 0, void 0, function* () {
            let buffer = yield collectPayload(binary);
            // @ts-ignore
            let decoder = new TextDecoder();
            let string = decoder.decode(buffer);
            // @ts-ignore
            let encoder = new TextEncoder();
            let encoded = encoder.encode(string);
            if (!compareArrays(buffer, encoded)) {
                throw `Expected payload to be UTF-8 encoded!`;
            }
            return string;
        });
    }
    exports.deserializeStringPayload = deserializeStringPayload;
    ;
    function deserializePayload(binary) {
        return __awaiter(this, void 0, void 0, function* () {
            let string = yield deserializeStringPayload(binary);
            if (string === "") {
                return;
            }
            let value = deserializeValue(string, false);
            if (value === undefined) {
                throw `Expected payload to be JSON encoded!`;
            }
            return value;
        });
    }
    exports.deserializePayload = deserializePayload;
    ;
});
define("node_modules/@joelek/ts-autoguard/dist/lib-shared/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/api", "node_modules/@joelek/ts-autoguard/dist/lib-shared/guards", "node_modules/@joelek/ts-autoguard/dist/lib-shared/serialization"], function (require, exports, api, guards, serialization) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serialization = exports.guards = exports.api = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serialization = exports.guards = exports.api = void 0;
    exports.api = api;
    exports.guards = guards;
    exports.serialization = serialization;
});
define("build/stream_types/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index"], function (require, exports, autoguard) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.FFProbe = exports.StreamType = exports.SubtitleStream = exports.AudioStream = exports.VideoStream = exports.Stream = void 0;
    exports.Stream = autoguard.guards.Object.of({
        "index": autoguard.guards.Number,
        "codec_type": autoguard.guards.String,
        "codec_name": autoguard.guards.String,
        "time_base": autoguard.guards.String,
        "start_pts": autoguard.guards.Number,
        "start_time": autoguard.guards.String,
        "tags": autoguard.guards.Group.of(autoguard.guards.Intersection.of(autoguard.guards.Record.of(autoguard.guards.String), autoguard.guards.Object.of({
            "language": autoguard.guards.String
        }, {})))
    }, {
        "extradata": autoguard.guards.String
    });
    exports.VideoStream = autoguard.guards.Group.of(autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.Stream), autoguard.guards.Object.of({
        "codec_type": autoguard.guards.StringLiteral.of("video"),
        "width": autoguard.guards.Number,
        "height": autoguard.guards.Number,
        "r_frame_rate": autoguard.guards.String
    }, {
        "sample_aspect_ratio": autoguard.guards.String,
        "display_aspect_ratio": autoguard.guards.String,
        "color_range": autoguard.guards.String,
        "color_space": autoguard.guards.String,
        "color_transfer": autoguard.guards.String,
        "color_primaries": autoguard.guards.String
    })));
    exports.AudioStream = autoguard.guards.Group.of(autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.Stream), autoguard.guards.Object.of({
        "codec_type": autoguard.guards.StringLiteral.of("audio"),
        "sample_rate": autoguard.guards.String,
        "channels": autoguard.guards.Number
    }, {})));
    exports.SubtitleStream = autoguard.guards.Group.of(autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.Stream), autoguard.guards.Object.of({
        "codec_type": autoguard.guards.StringLiteral.of("subtitle")
    }, {})));
    exports.StreamType = autoguard.guards.Group.of(autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.VideoStream), autoguard.guards.Reference.of(() => exports.AudioStream), autoguard.guards.Reference.of(() => exports.SubtitleStream)));
    exports.FFProbe = autoguard.guards.Object.of({
        "streams": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.StreamType))
    }, {});
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "Stream": autoguard.guards.Reference.of(() => exports.Stream),
            "VideoStream": autoguard.guards.Reference.of(() => exports.VideoStream),
            "AudioStream": autoguard.guards.Reference.of(() => exports.AudioStream),
            "SubtitleStream": autoguard.guards.Reference.of(() => exports.SubtitleStream),
            "StreamType": autoguard.guards.Reference.of(() => exports.StreamType),
            "FFProbe": autoguard.guards.Reference.of(() => exports.FFProbe)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/tesseract", ["require", "exports", "child_process"], function (require, exports, libcp) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.recognizeText = exports.getSupportedLanguages = void 0;
    function getSupportedLanguages(cb) {
        let options = [
            "tesseract",
            "--list-langs"
        ];
        libcp.exec(options.join(" "), (error, stdout, stderr) => {
            let lines = stdout.split(/\r\n|\n\r|\n|\r/)
                .map((line) => {
                return line.trim();
            })
                .filter((line) => {
                return line.length === 3;
            });
            return cb(lines);
        });
    }
    exports.getSupportedLanguages = getSupportedLanguages;
    function recognizeText(path, language, cb) {
        let options = [
            "tesseract",
            path,
            "stdout",
            "--psm", "6",
            "--oem", "1",
            "-l", language,
            "quiet"
        ];
        libcp.exec(options.join(" "), (error, stdout, stderr) => {
            if (error) {
                return cb([]);
            }
            let lines = stdout.split(/\r\n|\n\r|\n|\r/)
                .map((line) => {
                return line.trim();
            })
                .filter((line) => {
                return line.length > 0;
            })
                .map((line) => {
                line = line.replace(/\|/g, "I");
                line = line.replace(/\~/g, "-");
                line = line.replace(/\=/g, "-");
                line = line.replace(/\/g, "-");
                line = line.replace(/\/g, "-");
                line = line.replace(/\{/g, "(");
                line = line.replace(/\}/g, ")");
                line = line.replace(/\-+/g, "-");
                line = line.replace(/\'+/g, "'");
                line = line.replace(/\"+/g, "\"");
                line = line.replace(/^(-?)l /g, "$1I ");
                line = line.replace(/^(-?)1 ([^0-9])/g, "$1I $2");
                return line;
            });
            return cb(lines);
        });
    }
    exports.recognizeText = recognizeText;
});
define("build/ffprobe", ["require", "exports", "child_process", "build/stream_types/index", "build/tesseract"], function (require, exports, libcp, stream_types, tesseract) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getVideoStream = exports.getVideoStreamsToKeep = exports.getSubtitleStreamsToKeep = exports.getAudioStreamsToKeep = void 0;
    function getStreams(path, cb) {
        let options = [
            "ffprobe",
            "-v", "quiet",
            "-show_streams",
            "-show_data",
            "-print_format", "json",
            path
        ];
        libcp.exec(options.join(" "), (error, stdout, stderr) => {
            let json = JSON.parse(stdout);
            let ffprobe = stream_types.FFProbe.as(json);
            let streams = ffprobe.streams;
            return cb(streams);
        });
    }
    function getAudioStreams(path, cb) {
        getStreams(path, (streams) => {
            let audio_streams = streams.filter((stream) => stream_types.AudioStream.is(stream));
            return cb(audio_streams);
        });
    }
    function getAudioStreamsToKeep(path, cb) {
        let target_languages = ["eng", "swe", "jpn"];
        getAudioStreams(path, (audio_streams) => {
            let streams = target_languages.map((target_language) => {
                return audio_streams.filter((stream) => {
                    if (stream.tags.language !== target_language) {
                        return false;
                    }
                    return true;
                }).sort((one, two) => {
                    if (one.channels > two.channels) {
                        return -1;
                    }
                    if (one.channels < two.channels) {
                        return 1;
                    }
                    if (one.sample_rate > two.sample_rate) {
                        return -1;
                    }
                    if (one.sample_rate < two.sample_rate) {
                        return 1;
                    }
                    return 0;
                });
            }).filter((items) => {
                return items.length >= 1;
            }).map((items) => {
                return items[0];
            });
            if (streams.length === 0) {
                return cb(audio_streams.slice(0, 1));
            }
            return cb(streams);
        });
    }
    exports.getAudioStreamsToKeep = getAudioStreamsToKeep;
    function getSubtitleStreams(path, cb) {
        getStreams(path, (streams) => {
            let subtitles_stream = streams.filter((stream) => stream_types.SubtitleStream.is(stream));
            return cb(subtitles_stream);
        });
    }
    function getSubtitleStreamsToKeep(path, cb) {
        let target_languages = ["eng", "swe", "jpn"];
        tesseract.getSupportedLanguages((supported_languages) => {
            getSubtitleStreams(path, (subtitle_streams) => {
                let streams = target_languages.map((target_language) => {
                    return subtitle_streams.filter((stream) => {
                        if (stream.tags.language !== target_language) {
                            return false;
                        }
                        if (stream.codec_name === "dvd_subtitle" || stream.codec_name === "hdmv_pgs_subtitle") {
                            if (supported_languages.indexOf(target_language) === -1) {
                                return false;
                            }
                        }
                        return true;
                    }).sort((one, two) => {
                        if (one.codec_name === "subrip") {
                            if (two.codec_name === "subrip") {
                                return 0;
                            }
                            else {
                                return -1;
                            }
                        }
                        else {
                            if (two.codec_name === "subrip") {
                                return 1;
                            }
                            else {
                                return 0;
                            }
                        }
                    });
                }).filter((items) => {
                    return items.length >= 1;
                }).map((items) => {
                    return items[0];
                });
                return cb(streams);
            });
        });
    }
    exports.getSubtitleStreamsToKeep = getSubtitleStreamsToKeep;
    function getVideoStreams(path, cb) {
        getStreams(path, (streams) => {
            let video_streams = streams.filter((stream) => stream_types.VideoStream.is(stream));
            return cb(video_streams);
        });
    }
    function getVideoStreamsToKeep(path, cb) {
        getVideoStreams(path, (video_streams) => {
            let streams = video_streams;
            return cb(streams);
        });
    }
    exports.getVideoStreamsToKeep = getVideoStreamsToKeep;
    async function getVideoStream(path) {
        return new Promise((resolve, reject) => {
            getVideoStreamsToKeep(path, (video_streams) => {
                if (video_streams.length !== 1) {
                    return reject("Expected exactly one video stream!");
                }
                return resolve(video_streams[0]);
            });
        });
    }
    exports.getVideoStream = getVideoStream;
});
define("build/discdb/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index"], function (require, exports, autoguard) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.MediaDatabase = exports.Media = exports.MediaType = exports.MediaContent = exports.UnknownContent = exports.EpisodeContent = exports.MovieContent = exports.Content = void 0;
    exports.Content = autoguard.guards.Object.of({
        "type": autoguard.guards.String,
        "selector": autoguard.guards.String
    }, {});
    exports.MovieContent = autoguard.guards.Group.of(autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.Content), autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("movie"),
        "title": autoguard.guards.String,
        "year": autoguard.guards.Number,
        "part": autoguard.guards.Number,
        "imdb": autoguard.guards.String,
        "poster_url": autoguard.guards.String,
        "summary": autoguard.guards.String,
        "genres": autoguard.guards.Array.of(autoguard.guards.String),
        "actors": autoguard.guards.Array.of(autoguard.guards.String)
    }, {})));
    exports.EpisodeContent = autoguard.guards.Group.of(autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.Content), autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("episode"),
        "title": autoguard.guards.String,
        "show": autoguard.guards.String,
        "season": autoguard.guards.Number,
        "episode": autoguard.guards.Number,
        "imdb": autoguard.guards.String,
        "imdb_show": autoguard.guards.String,
        "year": autoguard.guards.Number,
        "summary_show": autoguard.guards.String,
        "summary": autoguard.guards.String,
        "genres_show": autoguard.guards.Array.of(autoguard.guards.String),
        "actors_show": autoguard.guards.Array.of(autoguard.guards.String)
    }, {
        "poster_url_show": autoguard.guards.String
    })));
    exports.UnknownContent = autoguard.guards.Group.of(autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.Content), autoguard.guards.Object.of({
        "type": autoguard.guards.StringLiteral.of("unknown")
    }, {})));
    exports.MediaContent = autoguard.guards.Group.of(autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.UnknownContent), autoguard.guards.Reference.of(() => exports.MovieContent), autoguard.guards.Reference.of(() => exports.EpisodeContent)));
    exports.MediaType = autoguard.guards.Group.of(autoguard.guards.Union.of(autoguard.guards.StringLiteral.of("paldvd"), autoguard.guards.StringLiteral.of("ntscdvd"), autoguard.guards.StringLiteral.of("bluray")));
    exports.Media = autoguard.guards.Object.of({
        "type": autoguard.guards.Reference.of(() => exports.MediaType),
        "content": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.MediaContent))
    }, {});
    exports.MediaDatabase = autoguard.guards.Record.of(autoguard.guards.Reference.of(() => exports.Media));
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "Content": autoguard.guards.Reference.of(() => exports.Content),
            "MovieContent": autoguard.guards.Reference.of(() => exports.MovieContent),
            "EpisodeContent": autoguard.guards.Reference.of(() => exports.EpisodeContent),
            "UnknownContent": autoguard.guards.Reference.of(() => exports.UnknownContent),
            "MediaContent": autoguard.guards.Reference.of(() => exports.MediaContent),
            "MediaType": autoguard.guards.Reference.of(() => exports.MediaType),
            "Media": autoguard.guards.Reference.of(() => exports.Media),
            "MediaDatabase": autoguard.guards.Reference.of(() => exports.MediaDatabase)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/utils", ["require", "exports", "build/discdb/index", "fs", "https"], function (require, exports, discdb, libfs, libhttps) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.request = exports.loadDatabase = exports.getBasename = exports.foreach = exports.pathify = void 0;
    function wordify(string) {
        return string
            .toLowerCase()
            .normalize("NFKD")
            .replace(/[\|\/\\\_\-]/g, " ")
            .replace(/[^a-z0-9 ]/g, "")
            .trim()
            .split(/[ ]+/g);
    }
    function pathify(string) {
        return wordify(string).join("_");
    }
    exports.pathify = pathify;
    function foreach(array, next, done) {
        array = array.slice();
        let iterate = () => {
            if (array.length > 0) {
                next(array.shift(), iterate);
            }
            else {
                done();
            }
        };
        iterate();
    }
    exports.foreach = foreach;
    function getBasename(type, content) {
        if (discdb.EpisodeContent.is(content)) {
            let rn = `${pathify(content.show)}-s${("00" + content.season).slice(-2)}e${("00" + content.episode).slice(-2)}-${pathify(content.title)}-${pathify(type)}`;
            return `./private/media/video/shows/${pathify(content.show)}/s${('00' + content.season).slice(-2)}/${rn}/${rn}`;
        }
        if (discdb.MovieContent.is(content)) {
            let title = pathify(content.title);
            let dir = title.substr(0, 1);
            let rn = `${title}-${('0000' + content.year).slice(-4)}-${pathify(type)}`;
            return `./private/media/video/movies/${dir}/${rn}/${("00" + content.part).slice(-2)}-${rn}`;
        }
        throw "";
    }
    exports.getBasename = getBasename;
    function loadDatabase(path, guard) {
        return guard(JSON.parse(libfs.readFileSync(path, "utf8")));
    }
    exports.loadDatabase = loadDatabase;
    async function request(url) {
        return new Promise((resolve, reject) => {
            const client_request = libhttps.request(url);
            client_request.on("response", (incoming_message) => {
                incoming_message.setEncoding("binary");
                const buffers = new Array();
                incoming_message.on("data", (chunk) => {
                    const buffer = Buffer.from(chunk, "binary");
                    buffers.push(buffer);
                });
                incoming_message.on("end", () => {
                    const body = Buffer.concat(buffers);
                    return resolve(body);
                });
            });
            client_request.on("error", (error) => {
                return reject(error);
            });
            client_request.end();
        });
    }
    exports.request = request;
});
define("build/reader", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Reader = void 0;
    function isString(value) {
        return value != null && value.constructor === String;
    }
    class Reader {
        string;
        offset;
        length;
        constructor(string) {
            this.string = string;
            this.offset = 0;
            this.length = string.length;
        }
        done() {
            return (this.offset === this.length);
        }
        line() {
            let string = "";
            while (!this.done()) {
                let one = this.string[this.offset];
                this.offset += 1;
                if (false) {
                }
                else if (one === "\r") {
                    if (!this.done()) {
                        let two = this.string[this.offset];
                        if (two === "\n") {
                            this.offset += 1;
                        }
                    }
                    break;
                }
                else if (one === "\n") {
                    if (!this.done()) {
                        let two = this.string[this.offset];
                        if (two === "\r") {
                            this.offset += 1;
                        }
                    }
                    break;
                }
                else {
                    string += one;
                }
            }
            return string;
        }
        keep(characters) {
            let string = "";
            while (!this.done()) {
                if (characters.indexOf(this.peek(1)) >= 0) {
                    break;
                }
                string += this.read(1);
            }
            return string;
        }
        peek(how) {
            let length = isString(how) ? how.length : how;
            let min = Math.min(this.offset, this.offset + length);
            let max = Math.max(this.offset, this.offset + length);
            if ((min < 0) || (min >= this.length) || (max < 0) || (max > this.length)) {
                throw "Unable to read between offsets " + min + " and " + max + " because length is " + this.length + "!";
            }
            let string = this.string.substring(min, max);
            if (isString(how)) {
                if (string !== how) {
                    throw "Expected \"" + how + "\" but read \"" + string + "\"!";
                }
            }
            return string;
        }
        read(how) {
            let string = this.peek(how);
            this.offset += string.length;
            return string;
        }
        seek(offset) {
            if ((offset < 0) || (offset >= this.length)) {
                throw "Unable to seek to offset " + offset + " because length is " + this.length + "!";
            }
            this.offset = offset;
        }
        skip(characters) {
            let string = "";
            while (!this.done()) {
                if (characters.indexOf(this.peek(1)) < 0) {
                    break;
                }
                string += this.read(1);
            }
            return string;
        }
        tell() {
            return this.offset;
        }
    }
    exports.Reader = Reader;
});
define("build/vtt", ["require", "exports", "build/reader"], function (require, exports, libreader) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encode = exports.decode = void 0;
    const DQ = "\"";
    function readString(reader, expected) {
        let string = reader.read(expected.length);
        if (string !== expected) {
            throw "Expected " + DQ + expected + DQ + " but read " + DQ + string + DQ + "!";
        }
    }
    function readBlank(reader) {
        let line = reader.line();
        if (line !== "") {
            throw "Expected a blank line but read " + DQ + line + DQ + "!";
        }
    }
    function readTimecode(reader) {
        let parts = null;
        if ((parts = /^([0-9][0-9])[:]([0-5][0-9])[:]([0-5][0-9])[.]([0-9][0-9][0-9])$/.exec(reader.peek(12))) != null) {
            reader.read(12);
            let hours = parseInt(parts[1], 10);
            let minutes = parseInt(parts[2], 10);
            let seconds = parseInt(parts[3], 10);
            let milliseconds = parseInt(parts[4], 10);
            return ((hours * 60 + minutes) * 60 + seconds) * 1000 + milliseconds;
        }
        if ((parts = /^([0-5][0-9])[:]([0-5][0-9])[.]([0-9][0-9][0-9])$/.exec(reader.peek(9))) != null) {
            reader.read(9);
            let hours = 0;
            let minutes = parseInt(parts[1], 10);
            let seconds = parseInt(parts[2], 10);
            let milliseconds = parseInt(parts[3], 10);
            return ((hours * 60 + minutes) * 60 + seconds) * 1000 + milliseconds;
        }
        console.log("Expected a valid timecode!");
        return 0;
    }
    function serializeTimecode(ms) {
        let s = Math.floor(ms / 1000);
        ms -= (s * 1000);
        let m = Math.floor(s / 60);
        s -= (m * 60);
        let h = Math.floor(m / 60);
        m -= (h * 60);
        let tch = `00${h}`.slice(-2);
        let tcm = `00${m}`.slice(-2);
        let tcs = `00${s}`.slice(-2);
        let tcms = `000${ms}`.slice(-3);
        return `${tch}:${tcm}:${tcs}.${tcms}`;
    }
    function readCue(reader) {
        let start_ms = readTimecode(reader);
        readString(reader, " --> ");
        let end_ms = readTimecode(reader);
        readBlank(reader);
        let duration_ms = end_ms - start_ms;
        if (duration_ms < 0) {
            console.log("Expected a positive duration but read " + start_ms + " and " + end_ms + "!");
        }
        let lines = new Array();
        while (true) {
            let line = reader.line();
            if (line === "") {
                break;
            }
            lines.push(line);
        }
        return {
            start_ms,
            duration_ms,
            lines
        };
    }
    function serializeCue(cue, options) {
        let lines = new Array();
        lines.push(serializeTimecode(cue.start_ms) + " --> " + serializeTimecode(cue.start_ms + cue.duration_ms));
        lines.push(...cue.lines);
        lines.push("");
        return lines.join(options.eol);
    }
    function readBody(reader) {
        let cues = new Array();
        while (!reader.done()) {
            let cue = readCue(reader);
            cues.push(cue);
        }
        return {
            cues
        };
    }
    function serializeBody(body, options) {
        let lines = new Array();
        for (let cue of body.cues) {
            lines.push(serializeCue(cue, options));
        }
        return lines.join(options.eol);
    }
    function readHead(reader) {
        readString(reader, "WEBVTT");
        let metadata = reader.line();
        readBlank(reader);
        return {
            metadata
        };
    }
    function serializeHead(head, options) {
        let lines = new Array();
        lines.push("WEBVTT " + head.metadata);
        lines.push("");
        return lines.join(options.eol);
    }
    function readTrack(reader) {
        let head = readHead(reader);
        let body = readBody(reader);
        return {
            head,
            body
        };
    }
    function serializeTrack(track, options) {
        let lines = new Array();
        lines.push(serializeHead(track.head, options));
        lines.push(serializeBody(track.body, options));
        return lines.join(options.eol);
    }
    function decode(string) {
        let reader = new libreader.Reader(string);
        return readTrack(reader);
    }
    exports.decode = decode;
    function encode(track) {
        return serializeTrack(track, {
            eol: "\r\n"
        });
    }
    exports.encode = encode;
});
define("build/vobsub", ["require", "exports", "fs", "child_process", "path", "crypto", "build/pgssub", "build/bmp", "build/delete_tree", "build/ffprobe", "build/utils", "build/tesseract", "build/vtt"], function (require, exports, libfs, libcp, libpath, libcrypto, pgssub, bmp, delete_tree, ffprobe, utils, tesseract, vtt) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateJobs = void 0;
    let read_file = (filename) => {
        let tf = 0;
        let bf = 0;
        let w = 0;
        let h = 0;
        let pts = parseInt(filename.split(libpath.sep).pop().split('.')[0], 10);
        let pts_start = pts;
        let pts_end = pts;
        let offset = 0;
        let fd = libfs.openSync(filename, 'r');
        let size = libfs.statSync(filename).size;
        let subtitle_packet = Buffer.alloc(size);
        offset += libfs.readSync(fd, subtitle_packet, 0, subtitle_packet.length, offset);
        libfs.closeSync(fd);
        offset = subtitle_packet.readUInt16BE(2);
        let last_command_sequence = false;
        let palette = null;
        let opacity = null;
        while (!last_command_sequence) {
            let timestamp = ((subtitle_packet.readUInt16BE(offset) << 10) / 90) | 0;
            let next_offset = subtitle_packet.readUInt16BE(offset + 2);
            last_command_sequence = (offset === next_offset);
            offset += 4;
            while (true) {
                let cmd = subtitle_packet.readUInt8(offset);
                offset += 1;
                if (false) {
                }
                else if (cmd === 0x00) {
                }
                else if (cmd === 0x01) {
                    pts_start = pts + timestamp;
                }
                else if (cmd === 0x02) {
                    pts_end = pts + timestamp;
                }
                else if (cmd === 0x03) {
                    let values = subtitle_packet.slice(offset, offset + 2);
                    offset += 2;
                    let a = ((values[0] & 0xF0) >> 4);
                    let b = ((values[0] & 0x0F) >> 0);
                    let c = ((values[1] & 0xF0) >> 4);
                    let d = ((values[1] & 0x0F) >> 0);
                    palette = Buffer.alloc(4);
                    palette[0] = d;
                    palette[1] = c;
                    palette[2] = b;
                    palette[3] = a;
                }
                else if (cmd === 0x04) {
                    let values = subtitle_packet.slice(offset, offset + 2);
                    offset += 2;
                    let a = ((values[0] & 0xF0) >> 4);
                    let b = ((values[0] & 0x0F) >> 0);
                    let c = ((values[1] & 0xF0) >> 4);
                    let d = ((values[1] & 0x0F) >> 0);
                    opacity = Buffer.alloc(4);
                    opacity[0] = d * 255 / 15;
                    opacity[1] = c * 255 / 15;
                    opacity[2] = b * 255 / 15;
                    opacity[3] = a * 255 / 15;
                }
                else if (cmd === 0x05) {
                    let values = subtitle_packet.slice(offset, offset + 6);
                    offset += 6;
                    let x1 = (((values[0] & 0xFF) >> 0) << 4) | ((values[1] & 0xF0) >> 4);
                    let x2 = (((values[1] & 0x0F) >> 0) << 8) | ((values[2] & 0xFF) >> 0);
                    let y1 = (((values[3] & 0xFF) >> 0) << 4) | ((values[4] & 0xF0) >> 4);
                    let y2 = (((values[4] & 0x0F) >> 0) << 8) | ((values[5] & 0xFF) >> 0);
                    w = (x2 - x1 + 1);
                    h = (y2 - y1 + 1);
                }
                else if (cmd === 0x06) {
                    let values = subtitle_packet.slice(offset, offset + 4);
                    offset += 4;
                    tf = values.readUInt16BE(0);
                    bf = values.readUInt16BE(2);
                }
                else if (cmd === 0xFF) {
                    break;
                }
                else {
                    throw new Error(`Unhandled command in command sequence.`);
                }
            }
            offset = next_offset;
        }
        let code_points = Buffer.alloc(subtitle_packet.length * 2);
        for (let i = 0; i < subtitle_packet.length; i++) {
            code_points[(i << 1) + 0] = ((subtitle_packet[i] & 0xF0) >> 4);
            code_points[(i << 1) + 1] = ((subtitle_packet[i] & 0x0F) >> 0);
        }
        let image = Buffer.alloc(w * h);
        let decode = (i, y, ymax) => {
            let x = 0;
            while (y < ymax) {
                let c0 = code_points[i++];
                let l = 0;
                let p = 0;
                if (c0 >= 4) {
                    l = ((c0 & 0x0C) >> 2);
                    p = ((c0 & 0x03) >> 0);
                }
                else if (c0 >= 1) {
                    let c1 = code_points[i++];
                    l = (c0 << 2) | ((c1 & 0x0C) >> 2);
                    p = ((c1 & 0x03) >> 0);
                }
                else {
                    let c1 = code_points[i++];
                    let c2 = code_points[i++];
                    if (c1 >= 4) {
                        l = (c1 << 2) | ((c2 & 0x0C) >> 2);
                        p = ((c2 & 0x03) >> 0);
                    }
                    else if (c1 >= 1) {
                        let c3 = code_points[i++];
                        l = (c1 << 6) | (c2 << 2) | ((c3 & 0x0C) >> 2);
                        p = ((c3 & 0x03) >> 0);
                    }
                    else {
                        let c3 = code_points[i++];
                        l = w - x;
                        p = ((c3 & 0x03) >> 0);
                    }
                }
                for (let i = (y * w) + x; i < (y * w) + x + l; i++) {
                    image[i] = p;
                }
                x = x + l;
                if (x >= w) {
                    x = 0;
                    y = y + 1;
                    i = (((i + 1) >> 1) << 1);
                }
            }
        };
        decode(tf << 1, 0, (h + 1) >> 1);
        decode(bf << 1, (h + 1) >> 1, h);
        let deinterlaced = Buffer.alloc(image.length);
        for (let y = 0; y < h; y++) {
            if ((y & 1) === 0) {
                let offset = (y >> 1) * w;
                image.copy(deinterlaced, y * w, offset, offset + w);
            }
            else {
                let offset = (((h + 1) >> 1) + (y >> 1)) * w;
                image.copy(deinterlaced, y * w, offset, offset + w);
            }
        }
        return {
            frame: deinterlaced,
            palette: palette,
            opacity: opacity,
            w: w,
            h: h,
            pts_start: pts_start,
            pts_end: pts_end
        };
    };
    let palette_from_ed = (ed) => {
        let buffer = Buffer.alloc(16 * 4);
        ed.split('\n').forEach((line) => {
            let parts;
            parts = /^palette: ([0-9a-f]{6}), ([0-9a-f]{6}), ([0-9a-f]{6}), ([0-9a-f]{6}), ([0-9a-f]{6}), ([0-9a-f]{6}), ([0-9a-f]{6}), ([0-9a-f]{6}), ([0-9a-f]{6}), ([0-9a-f]{6}), ([0-9a-f]{6}), ([0-9a-f]{6}), ([0-9a-f]{6}), ([0-9a-f]{6}), ([0-9a-f]{6}), ([0-9a-f]{6})$/.exec(line);
            if (parts !== null) {
                for (let i = 0; i < 16; i++) {
                    let rgb = parseInt(parts[i + 1], 16);
                    buffer[i * 4 + 0] = ((rgb >> 16) & 0xFF);
                    buffer[i * 4 + 1] = ((rgb >> 8) & 0xFF);
                    buffer[i * 4 + 2] = ((rgb >> 0) & 0xFF);
                    buffer[i * 4 + 3] = 0xFF;
                }
            }
            parts = /^custom colors: (ON|OFF), tridx: ([0-1]{4}), colors: ([0-9a-f]{6}), ([0-9a-f]{6}), ([0-9a-f]{6}), ([0-9a-f]{6})$/.exec(line);
            if (parts !== null) {
                console.log({ parts });
                let onoff = parts[1];
                if (onoff === 'ON') {
                    let tridx = parts[2];
                    for (let i = 0; i < 4; i++) {
                        let rgb = parseInt(parts[i + 3], 16);
                        buffer[i * 4 + 0] = ((rgb >> 16) & 0xFF);
                        buffer[i * 4 + 1] = ((rgb >> 8) & 0xFF);
                        buffer[i * 4 + 2] = ((rgb >> 0) & 0xFF);
                        buffer[i * 4 + 3] = (tridx[i] === '0') ? 0xFF : 0x00;
                    }
                }
            }
        });
        return buffer;
    };
    let image_hist = (image, palette) => {
        let palette_jump = Buffer.alloc(256);
        for (let i = 0; i < 256; i++) {
            let r = palette[i * 4 + 0];
            let g = palette[i * 4 + 1];
            let b = palette[i * 4 + 2];
            let o = palette[i * 4 + 3];
            for (let j = 0; j <= i; j++) {
                let r2 = palette[j * 4 + 0];
                let g2 = palette[j * 4 + 1];
                let b2 = palette[j * 4 + 2];
                let o2 = palette[j * 4 + 3];
                if (r === r2 && g === g2 && b === b2 && o === o2) {
                    palette_jump[i] = j;
                    break;
                }
            }
        }
        let hist = new Array(256);
        for (let i = 0; i < hist.length; i++) {
            hist[i] = 0;
        }
        for (let i = 0; i < image.frame.length; i++) {
            hist[palette_jump[image.frame[i]]]++;
        }
        return hist;
    };
    let write_file = (image, directory, ed) => {
        let palette = Buffer.alloc(256 * 4);
        let std_palette = palette_from_ed(ed);
        for (let i = 0; i < std_palette.length / 4; i++) {
            palette[i * 4 + 0] = std_palette[i * 4 + 0];
            palette[i * 4 + 1] = std_palette[i * 4 + 1];
            palette[i * 4 + 2] = std_palette[i * 4 + 2];
            palette[i * 4 + 3] = std_palette[i * 4 + 3];
        }
        if (image.palette) {
            for (let i = 0; i < image.palette.length; i++) {
                let k = image.palette[i];
                palette[i * 4 + 0] = std_palette[k * 4 + 0];
                palette[i * 4 + 1] = std_palette[k * 4 + 1];
                palette[i * 4 + 2] = std_palette[k * 4 + 2];
            }
        }
        if (image.opacity) {
            for (let i = 0; i < image.opacity.length; i++) {
                let k = image.opacity[i];
                palette[i * 4 + 3] = k;
            }
        }
        let y0 = 0;
        outer: for (; y0 < image.h; y0++) {
            inner: for (let x = 0; x < image.w; x++) {
                let k = image.frame[(y0 * image.w) + x];
                if (palette[k * 4 + 3] !== 0x00) {
                    break outer;
                }
            }
        }
        let y1 = image.h - 1;
        outer: for (; y1 > y0; y1--) {
            inner: for (let x = 0; x < image.w; x++) {
                let k = image.frame[(y1 * image.w) + x];
                if (palette[k * 4 + 3] !== 0x00) {
                    break outer;
                }
            }
        }
        let x0 = 0;
        outer: for (; x0 < image.w; x0++) {
            inner: for (let y = 0; y < image.h; y++) {
                let k = image.frame[(y * image.w) + x0];
                if (palette[k * 4 + 3] !== 0x00) {
                    break outer;
                }
            }
        }
        let x1 = image.w - 1;
        outer: for (; x1 > x0; x1--) {
            inner: for (let y = 0; y < image.h; y++) {
                let k = image.frame[(y * image.w) + x1];
                if (palette[k * 4 + 3] !== 0x00) {
                    break outer;
                }
            }
        }
        x0 -= 4;
        y0 -= 4;
        x1 += 4;
        y1 += 4;
        x0 = (x0 > 0) ? x0 : 0;
        y0 = (y0 > 0) ? y0 : 0;
        x1 = (x1 < image.w) ? x1 : image.w - 1;
        y1 = (y1 < image.h) ? y1 : image.h - 1;
        let neww = x1 - x0 + 1;
        let newh = y1 - y0 + 1;
        if (!(neww > 0 && newh > 0)) {
            return;
        }
        let newi = Buffer.alloc(neww * newh);
        for (let y = 0; y < newh; y++) {
            for (let x = 0; x < neww; x++) {
                newi[((y) * neww) + x] = image.frame[(y + y0) * image.w + (x + x0)];
            }
        }
        image.frame = newi;
        image.w = neww;
        image.h = newh;
        for (let i = 0; i < palette.length / 4; i++) {
            let o = palette[i * 4 + 3];
            /*
            if (i !== 1) {
                o = 0;
            }
            */
            if (o !== 0xFF) {
                let r = palette[i * 4 + 0];
                let g = palette[i * 4 + 1];
                let b = palette[i * 4 + 2];
                palette[i * 4 + 0] = (r * o / 255) | 0;
                palette[i * 4 + 1] = (g * o / 255) | 0;
                palette[i * 4 + 2] = (b * o / 255) | 0;
                palette[i * 4 + 3] = 0xFF;
            }
        }
        for (let i = 0; i < palette.length / 4; i++) {
            let r = palette[i * 4 + 0];
            let g = palette[i * 4 + 1];
            let b = palette[i * 4 + 2];
            let y = (r * 0.3 + g * 0.6 + b * 0.1) | 0;
            y = 255 - y;
            palette[i * 4 + 0] = y;
            palette[i * 4 + 1] = y;
            palette[i * 4 + 2] = y;
        }
        let hist = image_hist(image, palette);
        if (hist[0] === image.w * image.h) {
            return;
        }
        let ts0 = `00000000${image.pts_start}`.slice(-8);
        let ts1 = `00000000${image.pts_end}`.slice(-8);
        let filename = `${ts0}_${ts1}.bmp`;
        let stride = (((image.w + 3) >> 2) << 2);
        let bmp_header = Buffer.alloc(14);
        bmp_header.set(Buffer.from('BM', 'binary'), 0);
        bmp_header.writeUInt32LE(14 + 40 + 256 * 4 + stride * image.h, 2);
        bmp_header.writeUInt16LE(0, 6);
        bmp_header.writeUInt16LE(0, 8);
        bmp_header.writeUInt32LE(14 + 40 + 256 * 4, 10);
        let dib_header = Buffer.alloc(40);
        dib_header.writeUInt32LE(40, 0);
        dib_header.writeUInt32LE(image.w, 4);
        dib_header.writeUInt32LE(image.h, 8);
        dib_header.writeUInt16LE(1, 12);
        dib_header.writeUInt16LE(8, 14);
        dib_header.writeUInt32LE(0, 16);
        dib_header.writeUInt32LE(stride * image.h, 20);
        dib_header.writeUInt32LE(2835, 24);
        dib_header.writeUInt32LE(2835, 28);
        dib_header.writeUInt32LE(0, 32);
        dib_header.writeUInt32LE(0, 36);
        let fd = libfs.openSync(libpath.join(directory, filename), 'w');
        let offset = 0;
        offset += libfs.writeSync(fd, bmp_header, 0, bmp_header.length, offset);
        offset += libfs.writeSync(fd, dib_header, 0, dib_header.length, offset);
        offset += libfs.writeSync(fd, palette, 0, palette.length, offset);
        let row = Buffer.alloc(stride);
        for (let y = image.h - 1; y >= 0; y--) {
            let o = (y * image.w);
            image.frame.copy(row, 0, o, o + image.w);
            offset += libfs.writeSync(fd, row, 0, row.length, offset);
        }
        libfs.closeSync(fd);
    };
    let extract_vobsub = (filename, subn, cb) => {
        let jobid = libcrypto.randomBytes(16).toString('hex');
        libfs.mkdirSync(libpath.join('./private/temp/', jobid, 'raw'), { recursive: true });
        libfs.mkdirSync(libpath.join('./private/temp/', jobid, 'bmp'), { recursive: true });
        let cp = libcp.spawn('ffmpeg', [
            '-i', filename,
            '-map', `0:${subn}`,
            '-vn',
            '-an',
            '-c:s', 'copy',
            '-frame_pts', '1',
            `./private/temp/${jobid}/raw/%08d.raw`,
            "-v", "quiet"
        ]);
        cp.stdout.pipe(process.stdout);
        cp.stderr.pipe(process.stderr);
        process.stdin.pipe(cp.stdin);
        cp.on('exit', () => {
            cb(jobid);
        });
    };
    function extractSubrip(filename, subn, cb) {
        libcp.exec([
            'ffmpeg',
            '-i', filename,
            '-vn',
            '-an',
            '-map', `0:${subn}`,
            '-c:s', 'webvtt',
            "-f", "webvtt",
            'pipe:',
            "-v", "quiet"
        ].join(" "), (error, stdout, stderr) => {
            cb(stdout);
        });
    }
    let convert_to_bmp = (jobid, ed, codec, cb) => {
        let node = libpath.join('./private/temp/', jobid, 'raw');
        libfs.readdirSync(node).map((subnode) => {
            let innode = libpath.join(node, subnode);
            let name = subnode.split('.').slice(0, -1).join('.');
            let outnode = libpath.join('./private/temp/', jobid, 'bmp');
            if (codec === 'hdmv_pgs_subtitle') {
                let buffer = libfs.readFileSync(innode);
                let bitmap = pgssub.parse_pgssub_as_bmp(buffer);
                let pts = parseInt(innode.split(libpath.sep).pop().split('.')[0], 10);
                let output_filename = `${('00000000' + pts).slice(-8)}_${('00000000' + pts).slice(-8)}.bmp`;
                let output_path = libpath.join(outnode, output_filename);
                let bmp_file = bmp.write_to(bitmap);
                let fd = libfs.openSync(output_path, 'w');
                libfs.writeSync(fd, bmp_file);
                libfs.closeSync(fd);
            }
            else {
                write_file(read_file(innode), outnode, parse_extradata(ed));
            }
        });
        cb();
    };
    let ocr = (jobid, language, cb) => {
        process.stdout.write(`Recognizing "${language}" subtitles...\n`);
        let node = libpath.join('./private/temp/', jobid, 'bmp');
        let subtitles = [];
        let subnodes = libfs.readdirSync(node);
        let expected = subnodes.length;
        function finish() {
            subtitles = subtitles.sort((a, b) => {
                return a.pts_start - b.pts_start;
            });
            if (subtitles.length > 0) {
                for (let i = 0; i < subtitles.length - 1; i++) {
                    if (subtitles[i].pts_start === subtitles[i].pts_end) {
                        subtitles[i].pts_end = subtitles[i + 1].pts_start;
                    }
                }
                if (subtitles[subtitles.length - 1].pts_start === subtitles[subtitles.length - 1].pts_end) {
                    //subtitles[subtitles.length - 1].pts_end = duration;
                }
            }
            subtitles = subtitles.filter(st => st.lines.length > 0);
            cb(subtitles);
        }
        function pick(thread) {
            if (subnodes.length > 0) {
                let subnode = subnodes.shift();
                let name = subnode.split('.').slice(0, -1).join('.');
                let pts_start = parseInt(name.split('_')[0], 10);
                let pts_end = parseInt(name.split('_')[1], 10);
                let input = libpath.join(node, subnode);
                tesseract.recognizeText(input, language, (lines) => {
                    subtitles.push({ pts_start, pts_end, lines });
                    pick(thread);
                });
            }
            else {
                if (subtitles.length === expected) {
                    finish();
                }
            }
        }
        if (expected === 0) {
            return finish();
        }
        for (let i = 0; i < expected && i < 4; i++) {
            setTimeout(() => {
                pick(i);
            });
        }
    };
    let parse_extradata = (ed) => {
        let hex = ed.split('\n').map(line => line.substr(9, 42).split(' ').join('')).join('');
        let string = Buffer.from(hex, 'hex').toString('utf8');
        return string;
    };
    let parse_duration = (dur) => {
        let re = /^([0-9]{2})[:]([0-9]{2})[:]([0-9]{2})[.]([0-9]+)$/;
        let parts = re.exec(dur);
        if (parts == null) {
            return 0;
        }
        let h = parseInt(parts[1]);
        let m = parseInt(parts[2]);
        let s = parseInt(parts[3]);
        let ms = (parseFloat(`0.${parts[4]}`) * 1000 + 0.5) | 0;
        return ms + 1000 * (s + 60 * (m + 60 * h));
    };
    let to_timecode = (ms) => {
        let s = (ms / 1000) | 0;
        ms -= s * 1000;
        let m = (s / 60) | 0;
        s -= m * 60;
        let h = (m / 60) | 0;
        m -= h * 60;
        let tch = `00${h}`.slice(-2);
        let tcm = `00${m}`.slice(-2);
        let tcs = `00${s}`.slice(-2);
        let tcms = `000${ms}`.slice(-3);
        return `${tch}:${tcm}:${tcs}.${tcms}`;
    };
    function getArtifactPath(stream, basename) {
        return `${basename}.sub.${stream.tags.language}.vtt`;
    }
    function extractSingleStream(path, stream, basename, cb) {
        if (stream.codec_name === "subrip") {
            extractSubrip(path, stream.index, (webvtt) => {
                let track = vtt.decode(webvtt);
                track.head.metadata = JSON.stringify({
                    language: stream.tags.language
                });
                webvtt = vtt.encode(track);
                let outfile = getArtifactPath(stream, basename);
                let fd = libfs.openSync(outfile, 'w');
                libfs.writeSync(fd, webvtt);
                libfs.closeSync(fd);
                cb(outfile);
            });
            return;
        }
        extract_vobsub(path, stream.index, (jobid) => {
            convert_to_bmp(jobid, stream.extradata ?? "", stream.codec_name, () => {
                ocr(jobid, stream.tags.language, (subtitles) => {
                    let outfile = getArtifactPath(stream, basename);
                    if (subtitles.length > 0) {
                        let track = {
                            head: {
                                metadata: JSON.stringify({
                                    language: stream.tags.language
                                })
                            },
                            body: {
                                cues: subtitles.map((subtitle) => {
                                    return {
                                        start_ms: subtitle.pts_start,
                                        duration_ms: Math.max(0, subtitle.pts_end - subtitle.pts_start),
                                        lines: subtitle.lines
                                    };
                                })
                            }
                        };
                        let webvtt = vtt.encode(track);
                        let fd = libfs.openSync(outfile, 'w');
                        libfs.writeSync(fd, webvtt);
                        libfs.closeSync(fd);
                    }
                    delete_tree.async(libpath.join('./private/temp/', jobid), () => {
                        cb(outfile);
                    });
                });
            });
        });
    }
    function generateJobs(path, type, content, cb) {
        let basename = utils.getBasename(type, content);
        ffprobe.getSubtitleStreamsToKeep(path, (streams) => {
            let jobs = new Array();
            for (let stream of streams) {
                jobs.push({
                    getArtifactPath() {
                        return getArtifactPath(stream, basename);
                    },
                    produceArtifact(cb) {
                        extractSingleStream(path, stream, basename, cb);
                    }
                });
            }
            return cb(jobs);
        });
    }
    exports.generateJobs = generateJobs;
});
define("build/queue_metadata/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index"], function (require, exports, autoguard) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.Database = exports.Setting = exports.CropSettings = exports.FieldOrder = void 0;
    exports.FieldOrder = autoguard.guards.Group.of(autoguard.guards.Union.of(autoguard.guards.StringLiteral.of("bff"), autoguard.guards.StringLiteral.of("tff"), autoguard.guards.StringLiteral.of("progressive")));
    exports.CropSettings = autoguard.guards.Object.of({
        "w": autoguard.guards.Number,
        "h": autoguard.guards.Number,
        "x": autoguard.guards.Number,
        "y": autoguard.guards.Number
    }, {});
    exports.Setting = autoguard.guards.Object.of({
        "field_order": autoguard.guards.Reference.of(() => exports.FieldOrder),
        "crop": autoguard.guards.Reference.of(() => exports.CropSettings),
        "compressibility": autoguard.guards.Number
    }, {});
    exports.Database = autoguard.guards.Record.of(autoguard.guards.Reference.of(() => exports.Setting));
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "FieldOrder": autoguard.guards.Reference.of(() => exports.FieldOrder),
            "CropSettings": autoguard.guards.Reference.of(() => exports.CropSettings),
            "Setting": autoguard.guards.Reference.of(() => exports.Setting),
            "Database": autoguard.guards.Reference.of(() => exports.Database)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/ffmpeg", ["require", "exports", "child_process", "crypto", "path", "fs", "build/delete_tree", "build/discdb/index", "build/stream_types/index", "build/ffprobe", "build/queue_metadata/index", "build/utils"], function (require, exports, libcp, libcrypto, libpath, libfs, libdt, discdb_1, stream_types, ffprobe, queue_metadata, utils) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateJobs = void 0;
    let sdb = queue_metadata.Database.as(JSON.parse(libfs.readFileSync('./private/db/queue_metadata.json', "utf8")));
    let gcd = (a, b) => {
        if (!b) {
            return a;
        }
        return gcd(b, a % b);
    };
    let save_queue_metadata = (cb) => {
        let stats = sdb;
        let sorted = new Array();
        for (let key of Object.keys(stats)) {
            sorted.push({
                key: key,
                value: stats[key]
            });
        }
        sorted = sorted.sort((a, b) => {
            if (a.key < b.key) {
                return -1;
            }
            if (a.key > b.key) {
                return 1;
            }
            return 0;
        });
        let out = {};
        sorted.forEach((entry) => {
            out[entry.key] = entry.value;
        });
        let fd = libfs.openSync('./private/db/queue_metadata.json', 'w');
        libfs.writeSync(fd, JSON.stringify(out, null, `\t`));
        libfs.closeSync(fd);
        cb();
    };
    let format_detect = (path, cb) => {
        console.log(`Determining format...`);
        libcp.exec(`ffprobe -v quiet -print_format json -show_streams ${path}`, (error, stdout, stderr) => {
            let json = JSON.parse(stdout);
            for (let i = 0; json.streams && i < json.streams.length; i++) {
                let stream = json.streams[i];
                if (stream_types.VideoStream.is(stream)) {
                    let divisor = gcd(stream.width, stream.height);
                    let result = {
                        dimx: stream.width,
                        dimy: stream.height,
                        parx: parseInt(stream.sample_aspect_ratio?.split(':')?.[0] ?? "1"),
                        pary: parseInt(stream.sample_aspect_ratio?.split(':')?.[1] ?? "1"),
                        darx: parseInt(stream.display_aspect_ratio?.split(':')?.[0] ?? `${stream.width / divisor}`),
                        dary: parseInt(stream.display_aspect_ratio?.split(':')?.[1] ?? `${stream.height / divisor}`),
                        farx: (stream.width / divisor),
                        fary: (stream.height / divisor),
                        fpsx: parseInt(stream.r_frame_rate.split('/')[0]),
                        fpsy: parseInt(stream.r_frame_rate.split('/')[1]),
                        color_range: stream.color_range || null,
                        color_space: stream.color_space || null,
                        color_transfer: stream.color_transfer || null,
                        color_primaries: stream.color_primaries || null
                    };
                    let force_widescreen = false;
                    if (force_widescreen) {
                        let is_dvd_pal = result.dimx === 720 && result.dimy === 576 && result.fpsx === 25 && result.fpsy === 1;
                        if (is_dvd_pal) {
                            result.parx = 64;
                            result.pary = 45;
                            result.darx = 16;
                            result.dary = 9;
                        }
                        let is_dvd_ntsc = result.dimx === 720 && result.dimy === 480 && result.fpsx === 30000 && result.fpsy === 1001;
                        if (is_dvd_ntsc) {
                            result.parx = 32;
                            result.pary = 27;
                            result.darx = 16;
                            result.dary = 9;
                        }
                    }
                    if (result.parx === 186 && result.pary === 157 && result.darx === 279 && result.dary === 157) {
                        result.parx = 32;
                        result.pary = 27;
                        result.darx = 16;
                        result.dary = 9;
                    }
                    console.log(result);
                    cb(result);
                    break;
                }
                else {
                    throw `Expected a video stream!`;
                }
            }
        });
    };
    let interlace_detect = (path, cb) => {
        console.log(`Detecting interlace mode...`);
        libcp.execFile('ffmpeg', [
            '-i', path,
            '-vf', `select='between(mod(n\\,15000)\\,0\\,1499)',idet`,
            '-vsync', '0',
            '-an',
            '-f', 'null',
            '-'
        ], (error, stdout, stderr) => {
            let re;
            let parts;
            let imode = 'progressive';
            re = /\[Parsed_idet_[0-9]+\s+@\s+[0-9a-fA-F]{16}\]\s+Multi\s+frame\s+detection:\s+TFF:\s*([0-9]+)\s+BFF:\s*([0-9]+)\s+Progressive:\s*([0-9]+)\s+Undetermined:\s*([0-9]+)/;
            parts = re.exec(stderr);
            if (parts !== null) {
                let tff = parseInt(parts[1]);
                let bff = parseInt(parts[2]);
                let prog = parseInt(parts[3]);
                let undet = parseInt(parts[4]);
                let sum = tff + bff + prog + undet;
                if (tff > bff && tff > sum * 0.20) {
                    imode = 'tff';
                }
                else if (bff > tff && bff > sum * 0.20) {
                    imode = 'bff';
                }
                else {
                    imode = 'progressive';
                }
            }
            console.log(imode);
            cb(imode);
        });
    };
    let crop_detect = (path, picture, cb) => {
        console.log(`Detecting crop settings...`);
        libcp.execFile('ffmpeg', [
            '-i', `${path}`,
            '-vf', 'framestep=250,crop=iw-4:ih-4,bbox=24',
            '-an',
            '-f', 'null',
            '-'
        ], (error, stdout, stderr) => {
            let re;
            let parts;
            let x1s = new Array(picture.dimx - 4).fill(0);
            let x2s = new Array(picture.dimx - 4).fill(0);
            let y1s = new Array(picture.dimy - 4).fill(0);
            let y2s = new Array(picture.dimy - 4).fill(0);
            re = /\[Parsed_bbox_[0-9]+\s+@\s+[0-9a-fA-F]{16}\]\s+n:[0-9]+\s+pts:[0-9]+\s+pts_time:[0-9]+(?:\.[0-9]+)?\s+x1:([0-9]+)\s+x2:([0-9]+)\s+y1:([0-9]+)\s+y2:([0-9]+)/g;
            let samples = 0;
            while ((parts = re.exec(stderr)) !== null) {
                samples++;
                let x1 = parseInt(parts[1]);
                let x2 = parseInt(parts[2]);
                let y1 = parseInt(parts[3]);
                let y2 = parseInt(parts[4]);
                x1s[x1]++;
                x2s[x2]++;
                y1s[y1]++;
                y2s[y2]++;
            }
            if (samples === 0) {
                throw new Error();
            }
            let crop = {
                x1: 0,
                x2: (picture.dimx - 4),
                y1: 0,
                y2: (picture.dimy - 4)
            };
            for (let i = 0, sum = 0; i < x1s.length && sum < 0.75 * samples; i++) {
                crop.x1 = i;
                sum += x1s[i];
            }
            for (let i = x2s.length - 1, sum = 0; i >= 0 && sum < 0.75 * samples; i--) {
                crop.x2 = i;
                sum += x2s[i];
            }
            for (let i = 0, sum = 0; i < y1s.length && sum < 0.75 * samples; i++) {
                crop.y1 = i;
                sum += y1s[i];
            }
            for (let i = y2s.length - 1, sum = 0; i >= 0 && sum < 0.75 * samples; i--) {
                crop.y2 = i;
                sum += y2s[i];
            }
            crop.x1 += 2;
            crop.x2 += 2;
            crop.y1 += 2;
            crop.y2 += 2;
            crop.x1 += 4;
            crop.x2 -= 4;
            crop.y1 += 4;
            crop.y2 -= 4;
            let w = (crop.x2 - crop.x1 + 1);
            let h = (crop.y2 - crop.y1 + 1);
            let ar = (w * picture.parx / picture.pary / h);
            let candidates = [
                { w: 64, h: 27 },
                { w: 16, h: 9 },
                { w: 4, h: 3 }
            ];
            let deltas = candidates.map((candidate) => {
                return {
                    ...candidate,
                    delta: Math.abs(candidate.w / candidate.h - ar)
                };
            }).sort((a, b) => {
                if (a.delta < b.delta)
                    return -1;
                if (a.delta > b.delta)
                    return 1;
                return 0;
            });
            let darx = deltas[0].w;
            let dary = deltas[0].h;
            let dimx = darx * picture.pary;
            let dimy = dary * picture.parx;
            let dim_gcd = gcd(dimx, dimy);
            let cx = dimx / dim_gcd;
            let cy = dimy / dim_gcd;
            let virtualw = picture.dimx * cx / picture.farx;
            let virtualh = picture.dimy * cy / picture.fary;
            let tx = ((virtualw - w) / cx);
            let ty = ((virtualh - h) / cy);
            let t = tx > ty ? tx : ty;
            t = Math.ceil(t * 0.5) << 1;
            let nw = (virtualw - t * cx);
            let nh = (virtualh - t * cy);
            let mx = crop.x1 + (w * 0.5) - (nw * 0.5);
            let my = crop.y1 + (h * 0.5) - (nh * 0.5);
            let final = {
                w: nw,
                h: nh,
                x: mx | 0,
                y: my | 0
            };
            console.log(final);
            cb(final);
        });
    };
    let create_temp_dir = (cb) => {
        let id = libcrypto.randomBytes(16).toString('hex');
        let wd = libpath.join('./private/temp/', id);
        libfs.mkdirSync(wd, { recursive: true });
        cb(wd, id);
    };
    let get_frame_size = (k, farx, fary) => {
        let hw = 64 * k;
        let hh = hw * 9 / 16;
        // Reduce height for frames with 64:27 aspect ratio.
        if (farx * 9 > 16 * fary) {
            hh = hw * fary / farx;
        }
        // Reduce width for frames with 4:3 aspect ratio.
        if (farx * 9 < 16 * fary) {
            hw = hh * farx / fary;
        }
        let w = (hw << 1);
        let h = (hh << 1);
        return {
            w,
            h
        };
    };
    let encode_hardware = (filename, outfile, picture, rect, imode, compressibility, audio_streams, cb, sample_cadance, sample_keep, extraopts, overrides, video_stream, opt_content = null) => {
        picture = { ...picture };
        let is_dvd_pal = picture.dimx === 720 && picture.dimy === 576 && picture.fpsx === 25 && picture.fpsy === 1;
        let is_dvd_ntsc = picture.dimx === 720 && picture.dimy === 480 && picture.fpsx === 30000 && picture.fpsy === 1001;
        let is_fhd = picture.dimx === 1920 && picture.dimy === 1080;
        if (is_dvd_pal) {
            picture.color_space = picture.color_space || 'bt470bg';
            picture.color_transfer = picture.color_transfer || 'smpte170m';
            picture.color_primaries = picture.color_primaries || 'bt470bg';
            picture.color_range = picture.color_range || 'tv';
        }
        else if (is_dvd_ntsc) {
            picture.color_space = picture.color_space || 'smpte170m';
            picture.color_transfer = picture.color_transfer || 'smpte170m';
            picture.color_primaries = picture.color_primaries || 'smpte170m';
            picture.color_range = picture.color_range || 'tv';
        }
        else {
            picture.color_space = picture.color_space || 'bt709';
            picture.color_transfer = picture.color_transfer || 'bt709';
            picture.color_primaries = picture.color_primaries || 'bt709';
            picture.color_range = picture.color_range || 'tv';
        }
        let md = new Array();
        if (opt_content != null) {
            if (discdb_1.EpisodeContent.is(opt_content)) {
                md = [
                    '-metadata', `title=${opt_content.title}`,
                    '-metadata', `date=${opt_content.year}`,
                    '-metadata', `show=${opt_content.show}`,
                    '-metadata', `season_number=${opt_content.season}`,
                    '-metadata', `episode_sort=${opt_content.episode}`,
                    '-metadata', `episode_id=${opt_content.title}`,
                    "-metadata", `comment=${opt_content.summary}`
                ];
            }
            else if (discdb_1.MovieContent.is(opt_content)) {
                md = [
                    '-metadata', `title=${opt_content.title}`,
                    '-metadata', `date=${opt_content.year}`,
                    "-metadata", `track=${opt_content.part}`,
                    "-metadata", `comment=${opt_content.summary}`
                ];
            }
        }
        md.push("-metadata:s:v:0", "language=" + video_stream.tags.language);
        audio_streams.forEach((audio_stream, index) => {
            md.push("-metadata:s:a:" + index, "language=" + audio_stream.tags.language);
        });
        let interlace = '';
        if (imode === 'tff') {
            interlace = 'yadif=0:0:0,';
        }
        else if (imode === 'bff') {
            interlace = 'yadif=0:1:0,';
        }
        let frame_size = get_frame_size(is_fhd ? 15 : 8, picture.parx * rect.w, picture.pary * rect.h);
        let frameselect = `select='between(mod(n\\,${sample_cadance})\\,0\\,${sample_keep - 1})',`;
        let cp = libcp.spawn('ffmpeg', [
            ...extraopts,
            '-i', filename,
            '-vf', `format=yuv420p16le,${interlace}${frameselect}crop=${rect.w}:${rect.h}:${rect.x}:${rect.y},hqdn3d=1:1:5:5,scale=${frame_size.w}:${frame_size.h}`,
            '-an',
            '-v', 'quiet',
            '-f', 'rawvideo',
            'pipe:'
        ]);
        let mbx = ((frame_size.w + 16 - 1) / 16) | 0;
        let mby = ((frame_size.h + 16 - 1) / 16) | 0;
        let ref = (32768 / mbx / mby) | 0;
        ref = (ref > 8) ? 8 : ref;
        // let integer_fps = Math.round(picture.fpsx / picture.fpsy);
        // "-force_key_frames", `expr:eq(mod(n,${integer_fps}),0)`
        // keyint=${integer_fps * 2}:min-keyint={integer_fps}
        let x264 = `me=umh:subme=10:ref=${ref}:me-range=24:chroma-me=1:bframes=8:crf=20:nr=0:psy=1:psy-rd=1.0,1.0:trellis=2:dct-decimate=0:qcomp=0.6:deadzone-intra=0:deadzone-inter=0:fast-pskip=1:aq-mode=1:aq-strength=1.0:colorprim=${picture.color_primaries}:transfer=${picture.color_transfer}:colormatrix=${picture.color_space}`;
        let strength = Math.max(0.0, Math.min((1.0 - compressibility) * 0.1, 1.0));
        let cpx = libcp.spawn('denice', ['yuv420p16le', `${frame_size.w}`, `${frame_size.h}`, `${strength}`], { cwd: '../denice/build/' });
        let cp2 = libcp.spawn('ffmpeg', [
            '-f', 'rawvideo',
            '-pix_fmt', 'yuv420p16le',
            '-s', `${frame_size.w}:${frame_size.h}`,
            '-r', `${picture.fpsx}/${picture.fpsy}`,
            '-i', 'pipe:',
            ...extraopts,
            '-i', filename,
            '-map', '0:0',
            ...audio_streams.map((audio_stream) => {
                return ["-map", "1:" + audio_stream.index];
            }).reduce((previous, current) => {
                previous.push(...current);
                return previous;
            }, []),
            '-f', 'mp4',
            '-map_chapters', '-1',
            '-map_metadata', '-1',
            '-fflags', '+bitexact',
            '-movflags', '+faststart',
            '-vf', `gradfun=1:16`,
            '-c:v', 'libx264',
            '-preset', 'veryslow',
            '-x264-params', x264,
            '-ac', '2',
            '-c:a', 'aac',
            '-q:a', '2',
            ...md,
            ...overrides,
            outfile,
            '-y'
        ]);
        cp.stdout.pipe(cpx.stdin);
        cpx.stdout.pipe(cp2.stdin);
        cp2.stdout.pipe(process.stdout);
        cp2.stderr.pipe(process.stderr);
        cp2.on('exit', () => {
            cb(outfile);
        });
    };
    let compute_compressibility = (filename, picture, rect, imode, cb) => {
        console.log(`Detecting compressibility...`);
        let id1 = libcrypto.randomBytes(16).toString("hex");
        let id2 = libcrypto.randomBytes(16).toString("hex");
        let frames = 1;
        ffprobe.getVideoStreamsToKeep(filename, (video_streams) => {
            const stream = video_streams.shift();
            if (stream == null) {
                throw "";
            }
            create_temp_dir((wd, id) => {
                encode_hardware(filename, libpath.join(wd, id1), picture, rect, imode, 1.0, [], (outfile1) => {
                    encode_hardware(filename, libpath.join(wd, id2), picture, rect, imode, 1.0, [], (outfile2) => {
                        let s1 = libfs.statSync(outfile1).size;
                        let s2 = libfs.statSync(outfile2).size;
                        let c = 1.0 - (s2 - s1) / (frames * s1);
                        libdt.async(wd, () => {
                            let compressibility = Math.max(0.0, Math.min(c, 1.0));
                            console.log({ compressibility });
                            cb(compressibility);
                        });
                    }, 250, 1 + frames, ["-vsync", "0"], ["-f", "h264"], stream);
                }, 250, 1, ["-vsync", "0"], ["-f", "h264"], stream);
            });
        });
    };
    let determine_metadata = (filename, cb) => {
        format_detect(filename, (picture) => {
            crop_detect(filename, picture, (crop) => {
                interlace_detect(filename, (field_order) => {
                    compute_compressibility(filename, picture, crop, field_order, (compressibility) => {
                        cb({
                            picture,
                            settings: {
                                crop,
                                field_order,
                                compressibility
                            }
                        });
                    });
                });
            });
        });
    };
    let get_metadata = (filename, cb, basename) => {
        let parts = libpath.basename(filename).split(".");
        let key = parts.slice(0, -1).join(".");
        process.stderr.write(`Database key: ${key}\n`);
        const md = sdb[key];
        if (md != undefined) {
            format_detect(filename, (format) => {
                if (md.compressibility === 0) {
                    compute_compressibility(filename, format, md.crop, md.field_order, (comp) => {
                        md.compressibility = comp;
                        save_queue_metadata(() => {
                            cb({
                                picture: format,
                                settings: md
                            });
                        });
                    });
                }
                else {
                    cb({
                        picture: format,
                        settings: md
                    });
                }
            });
        }
        else {
            determine_metadata(filename, (md) => {
                sdb[key] = md.settings;
                save_queue_metadata(() => {
                    cb(md);
                });
            });
        }
    };
    function getArtifactPath(stream, basename) {
        return `${basename}.mp4`;
    }
    function transcodeSingleStream(path, stream, basename, content, cb) {
        get_metadata(path, (md) => {
            let extraopts = new Array();
            // extraopts = ['-ss', '0:15:00', '-t', '60'];
            ffprobe.getAudioStreamsToKeep(path, (audio_streams) => {
                create_temp_dir((wd, id) => {
                    let temp_path = libpath.join(wd, "video.mp4");
                    encode_hardware(path, temp_path, md.picture, md.settings.crop, md.settings.field_order, md.settings.compressibility, audio_streams, () => {
                        let target_path = getArtifactPath(stream, basename);
                        libfs.renameSync(temp_path, target_path);
                        libdt.async(wd, () => {
                            cb(target_path);
                        });
                    }, 1, 1, extraopts, [], stream, content);
                });
            });
        }, basename);
    }
    function generateJobs(path, type, content, cb) {
        let basename = utils.getBasename(type, content);
        ffprobe.getVideoStreamsToKeep(path, (video_streams) => {
            let jobs = new Array();
            for (let stream of video_streams) {
                jobs.push({
                    getArtifactPath() {
                        return getArtifactPath(stream, basename);
                    },
                    produceArtifact(cb) {
                        transcodeSingleStream(path, stream, basename, content, cb);
                    }
                });
            }
            return cb(jobs);
        });
    }
    exports.generateJobs = generateJobs;
});
define("build/cddb/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/dist/lib-shared/index"], function (require, exports, autoguard) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.Database = exports.Disc = exports.Track = exports.Volume = void 0;
    exports.Volume = autoguard.guards.Object.of({
        "replaygain_gain": autoguard.guards.Number,
        "replaygain_peak": autoguard.guards.Number,
        "mean_volume": autoguard.guards.Number,
        "peak_volume": autoguard.guards.Number
    }, {});
    exports.Track = autoguard.guards.Object.of({
        "number": autoguard.guards.Number,
        "artists": autoguard.guards.Array.of(autoguard.guards.String),
        "title": autoguard.guards.String
    }, {});
    exports.Disc = autoguard.guards.Object.of({
        "number": autoguard.guards.Number,
        "artists": autoguard.guards.Array.of(autoguard.guards.String),
        "title": autoguard.guards.String,
        "year": autoguard.guards.Number,
        "tracks": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => exports.Track))
    }, {
        "musicbrainz": autoguard.guards.String,
        "volume": autoguard.guards.Reference.of(() => exports.Volume),
        "cover_art_url": autoguard.guards.String
    });
    exports.Database = autoguard.guards.Record.of(autoguard.guards.Reference.of(() => exports.Disc));
    var Autoguard;
    (function (Autoguard) {
        Autoguard.Guards = {
            "Volume": autoguard.guards.Reference.of(() => exports.Volume),
            "Track": autoguard.guards.Reference.of(() => exports.Track),
            "Disc": autoguard.guards.Reference.of(() => exports.Disc),
            "Database": autoguard.guards.Reference.of(() => exports.Database)
        };
        Autoguard.Requests = {};
        Autoguard.Responses = {};
    })(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
    ;
});
define("build/audio_jobs", ["require", "exports", "child_process", "fs", "path", "build/cddb/index", "build/utils"], function (require, exports, libcp, libfs, libpath, cddb, utils) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createJobList = void 0;
    function makePath(components_ordered) {
        let components = components_ordered.slice().sort((one, two) => {
            return two.flex - one.flex;
        });
        while (true) {
            let candidate = components_ordered.map((component) => {
                return component.value;
            }).join("-");
            if (candidate.length <= 128) {
                return candidate;
            }
            let component = components.find((component) => {
                return component.flex > 0 && component.value.length > 0;
            });
            if (component == null) {
                throw "Unable to make path!";
            }
            component.value = component.value.split("_").slice(0, -1).join("_");
        }
    }
    function getPaths(disc, track) {
        let root = [
            ".",
            "private",
            "media",
            "audio"
        ];
        let disc_number = ("00" + disc.number).slice(-2);
        let disc_artist = utils.pathify(disc.artists.join("; "));
        let disc_title = utils.pathify(disc.title);
        let disc_year = ("0000" + disc.year).slice(-4);
        let suffix = "cd";
        let track_number = ("00" + track.number).slice(-2);
        let track_artist = utils.pathify(track.artists.join("; "));
        let track_title = utils.pathify(track.title);
        return [
            ...root,
            `${disc_artist}`,
            `${disc_artist}-${disc_year}-${disc_title}-${disc_number}-${suffix}`,
            makePath([
                {
                    value: track_number,
                    flex: 0
                },
                {
                    value: track_artist,
                    flex: 1
                },
                {
                    value: track_title,
                    flex: 2,
                },
                {
                    value: suffix,
                    flex: 0
                }
            ])
        ];
    }
    function getVolumeAdjustmentDecibels(volume) {
        let result = 0;
        if (volume != null) {
            let target_level_db = -18;
            let adjustment_db = target_level_db - volume.mean_volume;
            let max_adjustment_db = 0.0 - volume.peak_volume;
            let clipped_adjustment_db = Math.min(max_adjustment_db, adjustment_db);
            result = clipped_adjustment_db;
        }
        return result;
    }
    async function createAudioJob(source_path, metadata) {
        let disc = metadata.disc;
        let track = metadata.track;
        let paths = getPaths(disc, track);
        let target_path = paths.join("/") + ".mp4";
        if (libfs.existsSync(target_path)) {
            throw "Unable to create job!";
        }
        async function perform() {
            libfs.mkdirSync(paths.slice(0, -1).join("/"), { recursive: true });
            return new Promise((resolve, reject) => {
                let options = [
                    "-i", source_path,
                    "-af", `volume=${getVolumeAdjustmentDecibels(metadata.disc.volume)}dB`,
                    "-f", "mp4",
                    "-vn",
                    "-fflags", "+bitexact",
                    "-movflags", "+faststart",
                    "-c:a", "aac",
                    "-q:a", "2",
                    "-map_metadata", "-1",
                    "-metadata", `disc=${disc.number}`,
                    "-metadata", `album_artist=${disc.artists.join("; ")}`,
                    "-metadata", `album=${disc.title}`,
                    "-metadata", `date=${disc.year}`,
                    "-metadata", `track=${track.number}`,
                    "-metadata", `artist=${track.artists.join("; ")}`,
                    "-metadata", `title=${track.title}`,
                    target_path, "-y"
                ];
                console.log(`${source_path} --> ${target_path}`);
                let cp = libcp.spawn("ffmpeg", options);
                cp.on("error", reject);
                cp.on("close", resolve);
            });
        }
        return {
            perform
        };
    }
    async function getMetadata(source_path) {
        const db = utils.loadDatabase("./private/db/cddb.json", cddb.Database.as);
        let parts = libpath.basename(source_path).split(".");
        if (parts.length === 3) {
            let id = parts[0];
            let disc = db[id];
            if (disc != null) {
                let index = Number.parseInt(parts[1]);
                let track = disc.tracks[index];
                if (track != null) {
                    return {
                        disc,
                        track
                    };
                }
            }
        }
        throw "Unable to get metadata!";
    }
    async function createJobList(source_path) {
        let jobs = new Array();
        if (source_path.endsWith(".wav")) {
            let metadata = await getMetadata(source_path);
            try {
                jobs.push(await createAudioJob(source_path, metadata));
            }
            catch (error) { }
        }
        return jobs;
    }
    exports.createJobList = createJobList;
});
define("build/rate_limiter", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RateLimiter = void 0;
    class RateLimiter {
        average_request_time_ms;
        last_request_timestamp_ms;
        constructor(average_request_time_ms) {
            this.average_request_time_ms = average_request_time_ms;
            this.last_request_timestamp_ms = 0;
        }
        async rateLimit() {
            return new Promise((resolve, reject) => {
                const next_request_delay = Math.round(this.average_request_time_ms * (0.5 + Math.random()));
                const next_request_timestamp_ms = this.last_request_timestamp_ms + next_request_delay;
                const now_timestamp_ms = Date.now();
                const delay_ms = now_timestamp_ms >= next_request_timestamp_ms ? 0 : next_request_timestamp_ms - now_timestamp_ms;
                setTimeout(() => {
                    this.last_request_timestamp_ms = Date.now();
                    return resolve();
                }, delay_ms);
            });
        }
    }
    exports.RateLimiter = RateLimiter;
});
define("build/cover_art_jobs", ["require", "exports", "fs", "build/cddb/index", "build/utils", "build/rate_limiter"], function (require, exports, libfs, cddb, utils, rate_limiter) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createJobList = void 0;
    async function getMetadata(database, basename) {
        const parts = basename.split(".");
        if (parts.length === 3) {
            const id = parts[0];
            const media = database[id];
            if (media != null) {
                const index = Number.parseInt(parts[1]);
                const track = media.tracks[index];
                if (track != null) {
                    return {
                        id,
                        index,
                        media,
                        track
                    };
                }
            }
        }
        throw "Unable to get metadata!";
    }
    const rl = new rate_limiter.RateLimiter(10000);
    async function createJobListRecursively(database, directories) {
        const jobs = new Array();
        const entries = await libfs.promises.readdir(directories.join("/"), {
            withFileTypes: true
        });
        for (const entry of entries) {
            const basename = entry.name;
            if (entry.isDirectory()) {
                jobs.push(...await createJobListRecursively(database, [
                    ...directories,
                    basename
                ]));
                continue;
            }
            if (entry.isFile() && basename.endsWith(".wav")) {
                async function perform() {
                    const metadata = await getMetadata(database, basename);
                    const paths = [
                        ...directories,
                        metadata.id
                    ];
                    const path = paths.join("/") + ".jpg";
                    if (!libfs.existsSync(path)) {
                        if (metadata.media.cover_art_url != null) {
                            console.log(path);
                            libfs.mkdirSync(paths.slice(0, -1).join("/"), { recursive: true });
                            await rl.rateLimit();
                            const buffer = await utils.request(metadata.media.cover_art_url);
                            libfs.writeFileSync(path, buffer);
                        }
                    }
                }
                jobs.push({
                    perform
                });
                continue;
            }
        }
        return jobs;
    }
    async function createJobList() {
        const database = utils.loadDatabase("./private/db/cddb.json", cddb.Database.as);
        return createJobListRecursively(database, [
            ".",
            "private",
            "archive",
            "audio"
        ]);
    }
    exports.createJobList = createJobList;
});
define("build/cover_art_transcode_jobs", ["require", "exports", "child_process", "fs", "build/cddb/index", "build/utils"], function (require, exports, libcp, libfs, cddb, utils) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createJobList = void 0;
    async function getMetadata(database, basename) {
        const parts = basename.split(".");
        if (parts.length === 2) {
            const id = parts[0];
            const media = database[id];
            if (media != null) {
                return {
                    id,
                    media
                };
            }
        }
        throw "Unable to get metadata!";
    }
    async function getPaths(media) {
        const disc_artist = utils.pathify(media.artists.join("; "));
        const disc_year = ("0000" + media.year).slice(-4);
        const disc_title = utils.pathify(media.title);
        const disc_number = ("00" + media.number).slice(-2);
        const suffix = "cd";
        return [
            ".",
            "private",
            "media",
            "audio",
            `${disc_artist}`,
            `${disc_artist}-${disc_year}-${disc_title}-${disc_number}-${suffix}`,
            `00-artwork`,
        ];
    }
    async function writeBufferToDisk(buffer, path) {
        return new Promise((resolve, reject) => {
            const options = [
                "-i", "pipe:",
                "-vf", [
                    "scale=w=1080:h=1080:force_original_aspect_ratio=increase",
                    "crop=1080:1080",
                    "setsar=1:1"
                ].join(","),
                "-q:v", "1",
                "-f", "singlejpeg",
                "-fflags", "+bitexact",
                "-map_metadata", "-1",
                path, "-y"
            ];
            const ffmpeg = libcp.spawn("ffmpeg", options);
            ffmpeg.on("error", reject);
            ffmpeg.on("close", resolve);
            ffmpeg.stdin.end(buffer);
        });
    }
    async function createJobListRecursively(database, directories) {
        const jobs = new Array();
        const entries = await libfs.promises.readdir(directories.join("/"), {
            withFileTypes: true
        });
        for (const entry of entries) {
            const basename = entry.name;
            if (entry.isDirectory()) {
                jobs.push(...await createJobListRecursively(database, [
                    ...directories,
                    basename
                ]));
                continue;
            }
            if (entry.isFile() && basename.endsWith(".jpg")) {
                async function perform() {
                    const metadata = await getMetadata(database, basename);
                    const paths = await getPaths(metadata.media);
                    const path = paths.join("/") + ".jpg";
                    if (!libfs.existsSync(path)) {
                        console.log(path);
                        const buffer = libfs.readFileSync([
                            ...directories,
                            basename
                        ].join("/"));
                        libfs.mkdirSync(paths.slice(0, -1).join("/"), { recursive: true });
                        await writeBufferToDisk(buffer, path);
                    }
                }
                jobs.push({
                    perform
                });
                continue;
            }
        }
        return jobs;
    }
    async function createJobList() {
        const database = utils.loadDatabase("./private/db/cddb.json", cddb.Database.as);
        return createJobListRecursively(database, [
            ".",
            "private",
            "archive",
            "audio"
        ]);
    }
    exports.createJobList = createJobList;
});
define("build/poster_jobs", ["require", "exports", "fs", "build/discdb/index", "build/utils", "build/rate_limiter"], function (require, exports, libfs, discdb, utils, rate_limiter) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createJobList = void 0;
    async function getMetadata(database, basename) {
        const parts = basename.split(".");
        if (parts.length === 3) {
            const id = parts[0];
            const media = database[id];
            if (media != null) {
                const index = Number.parseInt(parts[1]);
                const track = media.content[index];
                if (track != null) {
                    return {
                        id,
                        index,
                        media,
                        track
                    };
                }
            }
        }
        throw "Unable to get metadata!";
    }
    const rl = new rate_limiter.RateLimiter(10000);
    async function createJobListRecursively(database, directories) {
        const jobs = new Array();
        const entries = await libfs.promises.readdir(directories.join("/"), {
            withFileTypes: true
        });
        for (const entry of entries) {
            const basename = entry.name;
            if (entry.isDirectory()) {
                jobs.push(...await createJobListRecursively(database, [
                    ...directories,
                    basename
                ]));
                continue;
            }
            if (entry.isFile() && basename.endsWith(".mkv")) {
                async function perform() {
                    const metadata = await getMetadata(database, basename);
                    const track = discdb.MovieContent.as(metadata.track);
                    const paths = [
                        ".",
                        "private",
                        "archive",
                        "image",
                        "movies",
                        track.imdb
                    ];
                    const path = paths.join("/") + ".jpg";
                    if (!libfs.existsSync(path)) {
                        console.log(path);
                        libfs.mkdirSync(paths.slice(0, -1).join("/"), { recursive: true });
                        await rl.rateLimit();
                        const buffer = await utils.request(track.poster_url);
                        libfs.writeFileSync(path, buffer);
                    }
                }
                jobs.push({
                    perform
                });
                continue;
            }
        }
        return jobs;
    }
    async function createJobList() {
        const database = utils.loadDatabase("./private/db/discdb.json", discdb.MediaDatabase.as);
        return createJobListRecursively(database, [
            ".",
            "private",
            "archive",
            "video",
            "movies"
        ]);
    }
    exports.createJobList = createJobList;
});
define("build/poster_transcode_jobs", ["require", "exports", "child_process", "fs", "build/discdb/index", "build/utils"], function (require, exports, libcp, libfs, discdb, utils) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createJobList = void 0;
    async function getMetadata(database, basename) {
        const parts = basename.split(".");
        if (parts.length === 2) {
            const id = parts[0];
            const media = database[id];
            if (media != null) {
                const index = 0;
                const track = media.content[index];
                if (track != null) {
                    return {
                        id,
                        index,
                        media,
                        track
                    };
                }
            }
        }
        throw "Unable to get metadata!";
    }
    async function getTargetPaths(media, track) {
        const title = utils.pathify(track.title);
        const year = ("0000" + track.year).slice(-4);
        const suffix = utils.pathify(media.type);
        const dir = title.substr(0, 1);
        const part = ("00" + 0).slice(-2);
        return [
            ".",
            "private",
            "media",
            "video",
            "movies",
            `${dir}`,
            `${title}-${year}-${suffix}`,
            "00-artwork",
        ];
    }
    async function writeBufferToDisk(buffer, path) {
        return new Promise((resolve, reject) => {
            const options = [
                "-i", "pipe:",
                "-vf", [
                    "scale=w=720:h=1080:force_original_aspect_ratio=increase",
                    "crop=720:1080",
                    "setsar=1:1"
                ].join(","),
                "-q:v", "1",
                "-f", "singlejpeg",
                "-fflags", "+bitexact",
                "-map_metadata", "-1",
                path, "-y"
            ];
            const ffmpeg = libcp.spawn("ffmpeg", options);
            ffmpeg.on("error", reject);
            ffmpeg.on("close", resolve);
            ffmpeg.stdin.end(buffer);
        });
    }
    async function createJobListRecursively(database, directories) {
        const jobs = new Array();
        const entries = await libfs.promises.readdir(directories.join("/"), {
            withFileTypes: true
        });
        for (const entry of entries) {
            const basename = entry.name;
            if (entry.isDirectory()) {
                jobs.push(...await createJobListRecursively(database, [
                    ...directories,
                    basename
                ]));
                continue;
            }
            if (entry.isFile() && basename.endsWith(".jpg")) {
                let parts = basename.split(".");
                if (parts.length !== 2) {
                    continue;
                }
                let imdb = parts[0];
                for (let value of Object.values(database)) {
                    if (value == null) {
                        continue;
                    }
                    let media = value;
                    for (let content of media.content) {
                        if (discdb.MovieContent.is(content)) {
                            let track = content;
                            if (track.imdb !== imdb) {
                                continue;
                            }
                            async function perform() {
                                const paths = await getTargetPaths(media, track);
                                const path = paths.join("/") + ".jpg";
                                if (!libfs.existsSync(path)) {
                                    console.log(path);
                                    const buffer = libfs.readFileSync([
                                        ...directories,
                                        basename
                                    ].join("/"));
                                    libfs.mkdirSync(paths.slice(0, -1).join("/"), { recursive: true });
                                    await writeBufferToDisk(buffer, path);
                                }
                            }
                            jobs.push({
                                perform
                            });
                        }
                    }
                }
                continue;
            }
        }
        return jobs;
    }
    async function createJobList() {
        const database = utils.loadDatabase("./private/db/discdb.json", discdb.MediaDatabase.as);
        return createJobListRecursively(database, [
            ".",
            "private",
            "archive",
            "image",
            "movies"
        ]);
    }
    exports.createJobList = createJobList;
});
define("build/show_poster_jobs", ["require", "exports", "fs", "build/discdb/index", "build/utils", "build/rate_limiter"], function (require, exports, libfs, discdb, utils, rate_limiter) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createJobList = void 0;
    async function getMetadata(database, basename) {
        const parts = basename.split(".");
        if (parts.length === 3) {
            const id = parts[0];
            const media = database[id];
            if (media != null) {
                const index = Number.parseInt(parts[1]);
                const track = media.content[index];
                if (track != null) {
                    return {
                        id,
                        index,
                        media,
                        track
                    };
                }
            }
        }
        throw "Unable to get metadata!";
    }
    const rl = new rate_limiter.RateLimiter(10000);
    async function createJobListRecursively(database, directories) {
        const jobs = new Array();
        const entries = await libfs.promises.readdir(directories.join("/"), {
            withFileTypes: true
        });
        for (const entry of entries) {
            const basename = entry.name;
            if (entry.isDirectory()) {
                jobs.push(...await createJobListRecursively(database, [
                    ...directories,
                    basename
                ]));
                continue;
            }
            if (entry.isFile() && basename.endsWith(".mkv")) {
                async function perform() {
                    const metadata = await getMetadata(database, basename);
                    const track = discdb.EpisodeContent.as(metadata.track);
                    const paths = [
                        ".",
                        "private",
                        "archive",
                        "image",
                        "shows",
                        track.imdb_show
                    ];
                    const path = paths.join("/") + ".jpg";
                    if (!libfs.existsSync(path) && track.poster_url_show != null) {
                        console.log(path);
                        libfs.mkdirSync(paths.slice(0, -1).join("/"), { recursive: true });
                        await rl.rateLimit();
                        const buffer = await utils.request(track.poster_url_show);
                        libfs.writeFileSync(path, buffer);
                    }
                }
                jobs.push({
                    perform
                });
                continue;
            }
        }
        return jobs;
    }
    async function createJobList() {
        const database = utils.loadDatabase("./private/db/discdb.json", discdb.MediaDatabase.as);
        return createJobListRecursively(database, [
            ".",
            "private",
            "archive",
            "video",
            "shows"
        ]);
    }
    exports.createJobList = createJobList;
});
define("build/show_poster_transcode_jobs", ["require", "exports", "child_process", "fs", "build/discdb/index", "build/utils"], function (require, exports, libcp, libfs, discdb, utils) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createJobList = void 0;
    async function getTargetPaths(media, track) {
        const show = utils.pathify(track.show);
        const title = utils.pathify(track.title);
        const season = ("00" + track.season).slice(-2);
        const episode = ("00" + track.episode).slice(-2);
        const suffix = utils.pathify(media.type);
        return [
            ".",
            "private",
            "media",
            "video",
            "shows",
            `${show}`,
            `s${season}`,
            `${show}-s${season}e${episode}-${title}-${suffix}`,
            "00-artwork",
        ];
    }
    async function writeBufferToDisk(buffer, path) {
        return new Promise((resolve, reject) => {
            const options = [
                "-i", "pipe:",
                "-vf", [
                    "scale=w=720:h=1080:force_original_aspect_ratio=increase",
                    "crop=720:1080",
                    "setsar=1:1"
                ].join(","),
                "-q:v", "1",
                "-f", "singlejpeg",
                "-fflags", "+bitexact",
                "-map_metadata", "-1",
                path, "-y"
            ];
            const ffmpeg = libcp.spawn("ffmpeg", options);
            ffmpeg.on("error", reject);
            ffmpeg.on("close", resolve);
            ffmpeg.stdin.end(buffer);
        });
    }
    async function createJobListRecursively(database, directories) {
        const jobs = new Array();
        const entries = await libfs.promises.readdir(directories.join("/"), {
            withFileTypes: true
        });
        for (const entry of entries) {
            const basename = entry.name;
            if (entry.isDirectory()) {
                jobs.push(...await createJobListRecursively(database, [
                    ...directories,
                    basename
                ]));
                continue;
            }
            if (entry.isFile() && basename.endsWith(".jpg")) {
                let parts = basename.split(".");
                if (parts.length !== 2) {
                    continue;
                }
                let imdb_show = parts[0];
                for (let value of Object.values(database)) {
                    if (value == null) {
                        continue;
                    }
                    let media = value;
                    for (let content of media.content) {
                        if (discdb.EpisodeContent.is(content)) {
                            let track = content;
                            if (track.imdb_show !== imdb_show) {
                                continue;
                            }
                            async function perform() {
                                const paths = await getTargetPaths(media, track);
                                const path = paths.join("/") + ".jpg";
                                if (!libfs.existsSync(path)) {
                                    console.log(path);
                                    const buffer = libfs.readFileSync([
                                        ...directories,
                                        basename
                                    ].join("/"));
                                    libfs.mkdirSync(paths.slice(0, -1).join("/"), { recursive: true });
                                    await writeBufferToDisk(buffer, path);
                                }
                            }
                            jobs.push({
                                perform
                            });
                        }
                    }
                }
                continue;
            }
        }
        return jobs;
    }
    async function createJobList() {
        const database = utils.loadDatabase("./private/db/discdb.json", discdb.MediaDatabase.as);
        return createJobListRecursively(database, [
            ".",
            "private",
            "archive",
            "image",
            "shows"
        ]);
    }
    exports.createJobList = createJobList;
});
define("build/json_metadata_jobs", ["require", "exports", "fs", "build/discdb/index", "build/utils"], function (require, exports, libfs, discdb, utils) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createJobList = void 0;
    async function getMetadata(database, basename) {
        const parts = basename.split(".");
        if (parts.length === 3) {
            const id = parts[0];
            const media = database[id];
            if (media != null) {
                const index = Number.parseInt(parts[1]);
                const track = media.content[index];
                if (track != null) {
                    return {
                        id,
                        index,
                        media,
                        track
                    };
                }
            }
        }
        throw "Unable to get metadata!";
    }
    async function getTargetPaths(media, track) {
        if (discdb.EpisodeContent.is(track)) {
            let show = utils.pathify(track.show);
            let season_number = ("00" + track.season).slice(-2);
            let episode_number = ("00" + track.episode).slice(-2);
            let title = utils.pathify(track.title);
            let suffix = utils.pathify(media.type);
            return [
                ".",
                "private",
                "media",
                "video",
                "shows",
                `${show}`,
                `s${season_number}`,
                `${show}-s${season_number}e${episode_number}-${title}-${suffix}`,
                `00-metadata`
            ];
        }
        if (discdb.MovieContent.is(track)) {
            let title = utils.pathify(track.title);
            let year = ("0000" + track.year).slice(-4);
            let suffix = utils.pathify(media.type);
            let dir = title.substr(0, 1);
            return [
                ".",
                "private",
                "media",
                "video",
                "movies",
                `${dir}`,
                `${title}-${year}-${suffix}`,
                `00-metadata`,
            ];
        }
        throw "Unable to get path!";
    }
    async function getJson(media, track) {
        if (discdb.EpisodeContent.is(track)) {
            const json = {
                type: "episode",
                imdb: track.imdb,
                title: track.title,
                year: track.year,
                summary: track.summary,
                show: {
                    imdb: track.imdb_show,
                    title: track.show,
                    summary: track.summary_show,
                    genres: track.genres_show,
                    actors: track.actors_show
                },
                season: track.season,
                episode: track.episode
            };
            return json;
        }
        if (discdb.MovieContent.is(track)) {
            const json = {
                type: "movie",
                imdb: track.imdb,
                title: track.title,
                year: track.year,
                summary: track.summary,
                genres: track.genres,
                actors: track.actors
            };
            return json;
        }
        throw "Unable to get json!";
    }
    async function createJobListRecursively(database, directories) {
        const jobs = new Array();
        const entries = await libfs.promises.readdir(directories.join("/"), {
            withFileTypes: true
        });
        for (const entry of entries) {
            const basename = entry.name;
            if (entry.isDirectory()) {
                jobs.push(...await createJobListRecursively(database, [
                    ...directories,
                    basename
                ]));
                continue;
            }
            if (entry.isFile() && basename.endsWith(".mkv")) {
                async function perform() {
                    const metadata = await getMetadata(database, basename);
                    const media = metadata.media;
                    const track = metadata.track;
                    const paths = await getTargetPaths(media, track);
                    const path = paths.join("/") + ".json";
                    if (!libfs.existsSync(path)) {
                        console.log(path);
                        libfs.mkdirSync(paths.slice(0, -1).join("/"), { recursive: true });
                        const json = await getJson(media, track);
                        libfs.writeFileSync(path, JSON.stringify(json, null, "\t") + "\n");
                    }
                }
                jobs.push({
                    perform
                });
                continue;
            }
        }
        return jobs;
    }
    async function createJobList() {
        const database = utils.loadDatabase("./private/db/discdb.json", discdb.MediaDatabase.as);
        return createJobListRecursively(database, [
            ".",
            "private",
            "archive",
            "video"
        ]);
    }
    exports.createJobList = createJobList;
});
define("build/jobs", ["require", "exports", "fs", "path", "build/vobsub", "build/ffmpeg", "build/discdb/index", "build/utils", "build/audio_jobs", "build/cover_art_jobs", "build/cover_art_transcode_jobs", "build/poster_jobs", "build/poster_transcode_jobs", "build/show_poster_jobs", "build/show_poster_transcode_jobs", "build/json_metadata_jobs"], function (require, exports, libfs, libpath, vobsub, ffmpeg, discdb_1, utils, audio_jobs, cover_art_jobs, cover_art_transcode_jobs, poster_jobs, poster_transcode_jobs, show_poster_jobs, show_poster_transcode_jobs, json_metadata_jobs) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    let move_files = (filenames, basename) => {
        basename = libpath.join(basename);
        let target_directory = ['.', 'private', 'media', ...basename.split(libpath.sep)];
        target_directory.pop();
        libfs.mkdirSync(target_directory.join(libpath.sep), { recursive: true });
        filenames.forEach((filename) => {
            filename = libpath.join(filename);
            let dirs = filename.split(libpath.sep);
            let file = dirs.pop();
            let parts = file.split('.');
            let ending = parts.slice(2).join('.');
            libfs.renameSync(filename, libpath.join('.', 'private', 'media', basename + '.' + ending));
        });
    };
    let generate_queue = (files, node) => {
        let stat = libfs.statSync(node);
        if (stat.isDirectory()) {
            libfs.readdirSync(node).map((subnode) => {
                return libpath.join(node, subnode);
            }).map((node) => {
                return generate_queue(files, node);
            });
        }
        else if (stat.isFile()) {
            files.push(node);
        }
        return files;
    };
    let queue = new Array();
    let db = discdb_1.MediaDatabase.as(JSON.parse(libfs.readFileSync("./private/db/discdb.json", "utf8")));
    let get_media_info = (path) => {
        let parts = libpath.basename(path).split(".");
        if (parts.length === 3) {
            let discid = parts[0];
            let index = Number.parseInt(parts[1]);
            let media = db[discid];
            if (media != null) {
                let content = media.content[index];
                if (content != null) {
                    return {
                        type: media.type,
                        content
                    };
                }
            }
        }
        return null;
    };
    function checkForJobs() {
        queue = generate_queue([], './private/archive/video/');
        pick_from_queue();
    }
    let pick_from_queue = () => {
        if (queue.length > 0) {
            let index = (Math.random() * queue.length) | 0;
            index = 0;
            let input = queue.splice(index, 1)[0];
            const mi = get_media_info(input);
            if (mi != null) {
                if (mi.type === 'paldvd' || mi.type === "ntscdvd" || mi.type === 'bluray') {
                    vobsub.generateJobs(input, mi.type, mi.content, (vobsub_jobs) => {
                        ffmpeg.generateJobs(input, mi.type, mi.content, (ffmpeg_jobs) => {
                            let jobs = [...vobsub_jobs, ...ffmpeg_jobs];
                            utils.foreach(jobs, (job, next) => {
                                const path = job.getArtifactPath();
                                libfs.mkdirSync(path.split("/").slice(0, -1).join("/"), { recursive: true });
                                if (libfs.existsSync(path)) {
                                    next();
                                }
                                else {
                                    job.produceArtifact((path) => {
                                        console.log(path);
                                        next();
                                    });
                                }
                            }, () => {
                                pick_from_queue();
                            });
                        });
                    });
                }
                return;
            }
            audio_jobs.createJobList(input)
                .then(async (jobs) => {
                for (let job of jobs) {
                    try {
                        await job.perform();
                    }
                    catch (error) { }
                }
            })
                .finally(() => {
                pick_from_queue();
            });
        }
        else {
            (async () => {
                let jobs = [
                    ...await json_metadata_jobs.createJobList(),
                    ...await poster_jobs.createJobList(),
                    ...await poster_transcode_jobs.createJobList(),
                    ...await show_poster_jobs.createJobList(),
                    ...await show_poster_transcode_jobs.createJobList(),
                    ...await cover_art_jobs.createJobList(),
                    ...await cover_art_transcode_jobs.createJobList()
                ];
                for (let job of jobs) {
                    try {
                        await job.perform();
                    }
                    catch (error) { }
                }
                process.exit(0);
            })();
        }
    };
    checkForJobs();
});
function define(e,t,l){let n=define;function u(e){return require(e)}null==n.moduleStates&&(n.moduleStates=new Map),null==n.dependentsMap&&(n.dependentsMap=new Map);let d=n.moduleStates.get(e);if(null!=d)throw"Duplicate module found with name "+e+"!";d={callback:l,dependencies:t,module:null},n.moduleStates.set(e,d);for(let l of t){let t=n.dependentsMap.get(l);null==t&&(t=new Set,n.dependentsMap.set(l,t)),t.add(e)}!function e(t){let l=n.moduleStates.get(t);if(null==l||null!=l.module)return;let d=Array(),o={exports:{}};for(let e of l.dependencies){if("require"===e){d.push(u);continue}if("module"===e){d.push(o);continue}if("exports"===e){d.push(o.exports);continue}try{d.push(u(e));continue}catch(e){}let t=n.moduleStates.get(e);if(null==t||null==t.module)return;d.push(t.module.exports)}l.callback(...d),l.module=o;let p=n.dependentsMap.get(t);if(null!=p)for(let t of p)e(t)}(e)}